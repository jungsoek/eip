# 1장. 요구사항 확인

## 1. 소프트웨어 생명 주기

### 1. 소프트웨어 생명 주기(Software Life Cycle)

소프트웨어 생명 주기는 소프트웨어 개발 방법론의 바탕이 되는 것으로, 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계별로 나눈 것이다.

* 소프트웨어 생명 주기는 소프트웨어 개발 단꼐와 각 단계별 주요 활동, 그리고 활동의 결과에 대한 산출물로 표현한다. 소프트웨어 수명 주기로고도 한다.
* 소프트웨어 생명 주기를 표현하는 형태를 소프트웨어 생명 주기 모형이라고 하며, 스프트웨어 프로세스 모형 또는 소프트웨어 공학 패러다임이라고도 한다.
* 개발자는 문제의 유형이나 개발 방법 등에 따라 특정 모형을 선택하여 사용할 수도 있고, 개별적인 모형을 사용할 수도 있다.
* 일반적으로 사용되는 소프트웨어 생명 주기 모형에는 폭포수 모형, 프로토타입 모형, 나선형 모형, 에자일 모형 등이 있다.

※ cf) : 소프트웨어 공학

소프트웨어 공학의 개념

* 소프트웨어 공학(SE)은 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문이며 어러 가지 방법론과 도구, 관리 기법등을 통하여 소프트웨어의 품질과 생산성 향상을 목적으로 한다.

* 소프트웨어 공학은 다음과 같이 여러 형태로 정의할 수 있다.

  * IEEE의 소프트웨어 공학 표준 용어사전

    소프트웨어의 개발, 운용, 유지보수, 폐기 처분에 대한 체계적인 접근 방인

  * Fairley

    지정된 비용과 기간 내에 소프트웨어를 체계적으로 생선하고 유지보수하는 데 관련된 기술적이고 관리적인 원리

  * Boehm

    과학적인 지식을 소프트웨어 설계와 제작에 응용하는 것이며 이를 개발, 운용, 유지보수하는 데 필요한 문서 작성 과정

소프트웨어 공학의 기본 원칙

* 현대적인 프로그래밍 기술을 계속적으로 적용해야 한다.
* 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 한다.
* 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다.

### 2. 폭포수 모형(Waterfall Model)

폭포수 모형은 폭포에서 한번 떨어진 물은 거슬러 올라갈 수 없듯이 소프트웨어 개발도 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론이다.

* 폭포수 모형은 소프트웨어 공학에서 가장 오래되고 가장 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형으로, 고전적 생명 주기 모형이라고도 한다.
* 소프트웨어 개발 과정의 한 단계가 끝나야만 다음 단계로 넘어갈 수 잇는 선형 순차적 모형이다.
* 모형을 적용한 경험과 성공 사례가 많다.
* 제품의 일부가 될 메뉴얼을 작성해야 한다.
* 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 한다.
* 두 개 이상의 과정이 병행하여 수행되지 않는다.

`타당성 검토` → `계획` → `요구 분석` → `설계` → `구현(코딩)` → `시험(검사)` → `유지보수`

### 3. 프로토타입 모형(Prototype Model, 원형 모형)

프로토타입 모형은 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본(시제)품을 만들어 최종 결과물을 예측하는 모형이다.

* 시제품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발한다.
* 시스템의 일부 혹은 시스템의 모형을 만드는 과정으로서 요구된 소프트웨어를 구현하는데, 이는 추수 구현 단계에서 사용될 골격 코드가 된다.
* 소프트웨어의 개발이 완료된 시점에서 오류가 발견되는 폭포수 모형의 단점을 보완하기 위한 모형이다.

![img](https://blog.kakaocdn.net/dn/dz3YHR/btqBRwWn0OT/rsUdp0Pa5GgJKm3MLwaVmk/img.png)

### 나선형(Spiral Model, 점진적 모형)

나선형 모형은 보헴이 제안한 것으로, 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형이다.

* 나선을 따라 돌듯이 어러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벅한 최종 소프트웨어를 개발하는 것으로, 점진적 모형이라고도 한다.
* 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 한다.
* 점진적으로 개발 과정이 반복되므로 누락되거나 추가된 요구사항을 첨가할 수 있고, 정밀하며, 유지보수 과정이 필요 없다.

![나선형모델.png](https://itwiki.kr/images/2/2a/%EB%82%98%EC%84%A0%ED%98%95%EB%AA%A8%EB%8D%B8.png)

### 5. 애자일 모형(Agile Model)

애자일은 '민첩한'이라는 의미로, 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발과정을 진행한다.

* 애자일 모형은 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭한다.
* 애자일 모형은 기업 활동 전반에 걸쳐 사용된다.
* 애자일 모형은 스프린트 또는 이터레이션이라고 불리는 짧은 개발 주기를 반복하며, 반복하는 주기마다 만들어지는 결과물에 대한 고객의 평가와 요구를 수용한다.
* 각 개발주기에는 고객이 요구사항에 우선순위를 부여하여 개발 작업을 진행한다.
* 소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구사항에 적합하다.
* 애자일 모형을 기반으로 하는 소프트웨어 개발 모형에는 스크럼, XP, 칸반, Lean, 크리스탈, ASD, 기능 중심 개발, DSDM, DAD 등이 있다.

<img src="https://post-phinf.pstatic.net/MjAxODEwMDJfMTQg/MDAxNTM4NDQ5NzM1MTM5.BpLR3vJkFRD5OBMWcyXG1qlE0pMsRhafMIV8MssiY1gg.vuCWTel5XbZTtId_F-Lp3Rh_I2Ckw6DRsoX9shdGtDIg.PNG/%EC%95%A0%EC%9E%90%EC%9D%BC%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.png?type=w1200" alt="img" style="zoom:67%;" />

※ cf) : 애자일 선언(Agile Manifesto)

2001년 17명의 애자일 전문 개발자가 공통의 관점을 정리해 '애자일 SW 개발 선언문'을 만들었다. 선언문에는 애자일 개발 철학이 담겨있는 4가지 핵심 가치와 애자일 개발을 실무에 적용할 때 기준이 되는 12가지 실행 지침이 담겨있는데, 그 내용은 다음과 같다.

* 애자일 개발 4가지 핵심 가치
  1. 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.
  2. 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.
  3. 계약 협상보다는 고객과 협업에 더 가치를 둔다.
  4. 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다.
* 애자일 개발 12가지 실행 지침
  1. 유용한 소프트웨어를 빠르고, 지속적으로 제공하여 고객을 만족시킨다.
  2. 개발 막바지라도 요구사항 변경을 적극 수용한다.
  3. 몇 개월이 아닌 몇 주 단위로 실행되는 소프트웨어를 제공한다.
  4. 고객과 개발자가 프로젝트 기간에 함께 일한다.
  5. 개발에 대한 참여 의지가 확실한 사람들로 팀을 구성하고, 필요한 개발 환경과 지원을 제공하며, 일을 잘 끝낼 수 있도록 신뢰한다.
  6. 같은 사무실에서 얼굴을 맞대고 의견을 나눈다.
  7. 개발의 진척도를 확인하는 1차 기준은 작동하는 소프트웨어이다.
  8. 지속 가능한 개발을 장려하고 일정한 속도로 개발을 진행한다.
  9. 기술적 우수성과 좋은 설계에 지속적인 관심을 기울이면 민첩성이 향상된다.
  10. 단순화를 추구한다.
  11. 최상의 아키텍쳐, 명확한 요구사항, 최상의 설계는 자기 스스로 일을 주도하는 조직적인 팀으로부터 나온다.
  12. 더 효과적인 팀이 될 수 있도록 방안을 정기적으로 깊이 고민하고 그에 따라 팀의 행동을 조정한다.

### 6. 폭포수 모형과 애자일의 비교

| 구분                 | 폭포수 모형                 | 애자일                                  |
| -------------------- | --------------------------- | --------------------------------------- |
| 새로운 요구사항 반영 | 어려움                      | 지속적으로 반영                         |
| 고객과의 의사소통    | 적음                        | 지속적임                                |
| 테스트               | 마지막에 모든 기능을 테스트 | 반복되는 일정 주기가 끝날 때마다 테스트 |
| 개발 중심            | 계획, 문서(메뉴얼)          | 고객                                    |

## 2. 스크럼(Scrum) 기법

### 1. 스크럼의 개요

스크럼이란 럭비에서 반칙으로 경기가 중단된 경우 양 팀의 선수들이 럭비공을 가운데 두고 상대팀을 밀치기 위해 서로 대치해 있는 대형을 말한다. 스크럼은 이처럼 팀이 중심이 되어 개발의 효율성을 높인다는 의미가 내포된 용어이다.

* 스크럼은 팀원 스스로가 스크럼 팀을 구성(self-organizing)해야 하며, 개발 작업에 관한 모든 것을 스스로 해결(cross-functional)할 수 있어야 한다.
* 스크럼 팀은 제품 책임자, 스크럼 마스터, 개발팀으로 구성된다.
  * 제품 책임자(PO; Product Owner)
    * 이해관계자들 중 개발될 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사 결정할 사람으로 선정하는데, 주로 개발 의뢰자나 사용자가 담당한다.
    * 이해관계자들의 의견을 종합하여 제품에 대한 요구사항을 작성하는 주체다.
    * 요구사항이 담긴 백로그(Backlog)를 작성하고 백로그에 대한 우선순위를 지정한다.
    * 팀원들이 백로그에 스토리를 추가할 수는 있지만 우선순위를 지정할 수는 없다.
    * 제품에 대한 테스트를 수행하면서 주기적으로 요구사항의 우선순위를 갱신한다.
  * 스크럼 마스터(SM; Scrum Master)
    * 스크럼 팀이 스크럼을 잘 수행할 수 있도록 객관적인 시각에서 조언을 해주는 가이드 역할을 수행한다. 팀원들을 통제하는 것이 목표가 아니다.
    * 일일 스크럼 회의를 주관하여 진행 사항을 점검하고, 개발 과정에서 발생된 장애 요소를 공론화하여 처리한다.
  * 개발팀(DT; Development Team)
    * 제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로, 개발자 외에도 디자이너, 테스터 등 제품 개발을 위해 참여하는 모든 사람이 대상이 된다.
    * 보통 최대 인원은 7 ~ 8명이 적당하다.

### 2. 스크럼 개발 프로세스

![img](https://velog.velcdn.com/images/octo__/post/0ba1ec28-0ed6-48fc-9814-111568f6a874/image.png)

* 제품 백로그(Product Backlog)
  * 제품 개발에 필요한 모든 요구사항(User Story)을 우선순위에 따라 나열한 목록이다.
  * 개발 과정에서 새롭게 도출되는 요구사항으로 인해 지속적으로 업데이트된다.
  * 제품 백로그에 작성된 사용자 스토리를 기반으로 전체 일정 계획인 릴리즈 계획(Release Plan)을 수립한다.
* 스프린트 계획 회의(Sprint Planning Meeting)
  * 제품 백로그 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립하는 것이다.
  * 스프린트에서 처리할 요구사항(User Story)을 개발자들이 나눠서 작업할 수 있도록 태스크(Task)라는 작업 단위로 분할한 후 개발자별로 수행할 작업 목록인 스프린트 백로그(Sprint Backlog)를 작성한다.
* 스프린트(Sprint)
  * 실제 개발 작업을 진행하는 과정으로, 보통 2-4주 정도의 기간 내에서 진행한다.
  * 스프린트 백로그에 작성된 태스크를 대상으로 작업 시간(양)을 추정한 후 개발 담당자에게 할당한다.
  * 태스크를 할당할 때는 개발자가 원하는 태스크를 직접 선별하여 담당할 수 있도록 하는 것이 좋다.
  * 개발 담당자에게 할당된 태스크는 보통 할 일(To Do), 진행 중(In Progress), 완료(Done)의 상태를 갖는다.
* 일일 스크럼 회의(Daily Scrum Meeting)
  * 모든 팀원이 매일 약속된 시간에 약 15분 정도의 짧은 시간동안 진행 상황을 점검한다.
  * 회의는 보통 서서 진행하며, 남은 작업 시간은 소멸 차트(Burn-down Chart)에 표시한다.
  * 스크럼 마스터는 발견된 장애 요소를 해결할 수 있도록 도와준다.
* 스프린트 검토 회의(Sprint Review)
  * 부분 또는 전체 완성 제품이 요구사항에 잘 부합되는지 사용자가 포함된 참석자 앞에서 테스팅을 수행한다.
  * 스프린트의 한 주당 한 시간 내에서 진행한다.
  * 제품 책임자(Product Owner)는 개선할 사항에 대한 피드백을 정리한 후 다음 스프린트에 반영할 수 있도록 제품 백로그를 업데이트한다.
* 스프린트 회고(Sprint Retrospective)
  * 스프린트 주기를 되돌아보며 정해놓은 규칙을 잘 준수했는지, 개선할 점은 없는지 등을 확인하고 기록한다.
  * 해당 스프린트가 끝난 시점에서 수행하거나 일정 주기로 수행한다.

## 3. XP(extreme programming) 기법

### 1. XP(extreme programming)

XP(extreme programming)는 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법이다.

* XP는 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.
* 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높인다.
* 릴리즈 테스트마다 고객을 직접 참여시킴으로써 요구한 기능이 제대로 작동하는지 고객이 직접 확인할 수 있다.
* 비교적 소규모 인원의 개발 프로젝트에 효과적이다.
* XP의 5가지 핵심 가치 : 의사소통(Communication), 단순성(Simplicity), 용기(Courage), 존중(Respect), 피드백(Feedback)

### XP 개발 프로세스

![img](https://notedailyit.co.kr/wp-content/uploads/2023/07/IMG_0875.png)

* 사용자 스토리(User Story)
  * 고객의 요구사항을 간단한 시나리오로 표현한 것이다.
  * 내용은 기능 단위로 구성하며, 필요한 경우 간단한 테스트 사항(Test Case)도 기재한다.
* 릴리즈 계획 수립(Release Planning)
  * 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것을 릴리즈라고 한다.
  * 부분 혹은 전체 개발 완료 시점에 대한 일정을 수립한다.
* 스파이크(Spike)
  * 요구사항의 신뢰성을 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램이다.
  * 처리할 문제 외의 다른 조건은 모두 무시하고 작성한다.
* 이터레이션(Iteration)
  * 하나의 릴리즈를 더 세분화 한 단위를 이터레이션(iteration)이라고 한다.
  * 일반적으로 1-3주 정도의 기간으로 진행된다.
  * 이 기간 중에 새로운 스토리가 작성될 수 있으며, 작성된 스토리는 진행 중인 이터레이션 혹은 다음 이터레이션에 포함될 수 있다.
* 승인 검사(Acceptance Test, 인수 테스트)
  * 하나의 이터레이션 안에서 계획된 릴리즈 단위의 부분 완료 제품이 구현되면 수행하는 테스트이다.
  * 사용자 스토리 작성 시 함께 기재한 테스트 사항에 대해 고객이 직접 수행한다.
  * 테스트 과정에서 발견한 오류 사항은 다음 이터레이션에 포함한다.
  * 테스트 이후 새로운 요구사항이 작성되거나 요구사항의 상대적 우선순위가 변경될 수 있다.
  * 테스트가 완료되면 다음 이터레이션을 진행한다.
* 소규모 릴리즈(Small Release)
  * 릴리즈를 소규모로 하게 되면, 고객의 반응을 기능별로 확인할 수 있어, 고객의 요구사항에 좀 더 유연하게 대응할 수 있다.
  * 계획된 릴리즈 기간 동안 진행된 이터레이션이 모두 완료되면 고객에 의한 최종 테스트를 수행한 후 릴리즈, 즉 최종 결과물을 고객에게 전달한다.
  * 릴리즈가 최종 완제품이 아닌 경우 다음 릴리즈 일정에 맞게 개발을 계속 진행한다.

※ cf) : XP의 주요 실천 방법(Practice)

| 실천 방법                                                  | 내용                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| Pair Programming(짝 프로그래밍)                            | 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성한다. |
| Collective Ownership(공동 코드 소유)                       | 개발 코드에 대한 권한과 책임을 공동으로 소유한다.            |
| Test-Driven Development(테스트 주도 개발)                  | * 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지 정확히 파악한다.<br />* 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구(구조, 프레임워크)를 사용한다. |
| Whole Team(전체 팀)                                        | 개발에 참여하는 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 한다. |
| Continuous Integration(지속적 통합)                        | 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합한다. |
| Design Improvement(디자인 개선) 또는 Refactoring(리팩토링) | 프로그램 기능의 변경 없이, 단순화, 유연성 강화 등을 통해 시스템을 재구성한다. |
| Small Release(소규모 릴리즈)                               | 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있다. |

## 4. 현행 시스템 파악

### 1. 현행 시스템 파악 절차

새로 개발하려는 시스템의 개발 범위를 명확히 설정하기 위해 현행 시스템의 구성과 제공 기능, 시스템 간의 전달 정보, 사용되는 기술 요소, 소프트웨어, 하드웨어, 그리고 네트워크의 구성 등을 파악한다.

![img](https://postfiles.pstatic.net/MjAyMDA0MTRfMjY4/MDAxNTg2ODMwODIxMDE0.QVDbBVZaU6FM3EAyXqaCI-iHKstz_3eFXFZdP2AujL0g.ELRBdQRKIliz7bAQbS75bbhcXhuDTmIQ-pJo0BVcYD0g.PNG.ehtm/image.png?type=w773)

### 2. 시스템 구성 파악

현행 시스템의 구성은 조직의 주요 업무를 담당하는 기간 업무와 이를 지원하는 지원 업무로 구분하여 기술한다.

* 조직 내에 있는 모든 정보시스템의 현황을 파악할 수 있도록 각 업무에 속하는 단위 업무 정보시스템들의 명칭, 주요 기능들을 명시한다.

ex) 금융 기관의 여신관리 업무와 고객관리 업무 시스템 현황

![image-20240420210110159](/home/oem/engineer_information_processing/assets/image-20240420210110159.png)

### 3. 시스템 기능 파악

현행 시스템의 기능은 단위 업무 시스템이 현재 제공하는 기능들을 주요 기능과 하부 기능, 세부 기능으로 구분하여 계층형으로 표시한다.

ex) 여신상담 관리 시스템의 주요 기능과 하부, 세부 기능

![image-20240420211216076](/home/oem/engineer_information_processing/assets/image-20240420211216076.png)

### 4. 시스템 인터페이스 파악

현행 시스템의 인터페이스에는 단위 업무 시스템 간에 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시한다.

* 데이터를 어떤 형식으로 주고받는지, 통신규약은 무엇을 사용하는지, 연계 유형은 무엇인지 등을 반드시 고려해야 한다.

ex) 여신상담 관리 시스템의 인터페이스 현황

![image-20240420211346010](/home/oem/engineer_information_processing/assets/image-20240420211346010.png)

### 5. 아키텍처 구성 파악

현행 시스템의 아키텍처 구성은 기간 업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성한다.

* 아키텍처가 단위 업무 시스템별로 다른 경우에는 가장 핵심이 되는 기간 업무 처리 시스템을 기준으로 표현한다.

ex) 회원 정보 관리 시스템 아키텍처 구성도

![img](https://funyphp.com/data/editor/2102/20210201161357_1f1380483b5909dcd774d7be2b351af2_sz48.png)

### 6. 소프트웨어 구성 파악

소프트웨어 구성에는 단위 업무 시스템별로 업무 처리를 위해 설치되어 있는 소프트웨어들의 제품명, 용도, 라이선스 적용 방식, 라이언스 수 등을 명시한다.

* 시스템 구축비용 면에서 소프트웨어 비용이 적지 않은 비중을 차지하므로, 상용 소프트웨어의 경우 라이선스 적용 방식의 기준과 보유한 라이선스의 파악이 중요하다.

ex) 단위 업무 시스템별 소프트웨어 현황

![image-20240420223734548](/home/oem/engineer_information_processing/assets/image-20240420223734548.png)

### 7. 하드웨어 구성 파악

하드웨어 구성에는 단위 업무 시스템들이 운용되는 서버의 주요 사항과 수량, 그리고 이중화의 적용 여부를 명시한다. 

* 서버의 이중화는 기간 업무의 서비스 기간, 장애 대응 정책에 따라 필요 여부가 결정된다.
* 현행 시스템에 이중화가 적용된 경우 대부분 새로 구성될 시스템에도 이중화가 필요하므로 이로 인한 비용 증가와 시스템 구축 난이도가 높아질 가능성을 고려해야 한다.

ex) 단위 업무 시스템별 하드웨어 현황

![image-20240420224845831](/home/oem/engineer_information_processing/assets/image-20240420224845831.png)

### 8. 네트워크 구성 파악

네트워크 구성은 업무 시스템들의 네트워크 구성을 파악할 수 있도록 서버의 위치, 서버 간의 네트워크 연결 방식을 네트워크 구성도로 작성한다.

* 네트워크 구성도를 통해 서버들의 물리적인 위치 관계를 파악할 수 있고 보안 취약성을 분석하여 적절한 대응을 할 수 있다.
* 네트워크에 장애가 발생한 경우 발생 원인을 찾아 복구하기 위한 용도로 활용될 수 있다.

ex) 자원관리팀, 마케팅팀, 업무 지원팀의 인터넷 접속을 위한 네트워크 구성도

![img](https://velog.velcdn.com/images/esjw_/post/7004b81d-fbbc-4310-bf2c-e1d1e6ee3773/image.png)

## 5. 개발 기술 환경 파악

### 1. 개발 기술 환경의 정의

개발하고자 하는 소프트웨어와 관련된 운영체제(OS), 데이터베이스 관리 시스템(DBMS), 미들웨어(Middle Ware) 등을 선정할 때 고려해야 할 사항을 기술하고, 오픈 소스 사용 시 주의해야 할 내용을 제시한다.

### 2. 운영체제(OS)

운영체제는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어이다.

* 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다.
* 컴퓨터 운영체제의 종류에는 Windows, UNIX, Linux, Mac OS 등이, 모바일 운영체제에는 iOS, Android 등이 있다.

### 3. 운영체제 관련 요구사항 식별 시 고려사항

운영체제와 관련된 요구사항 식별 시 다음과 같은 사항을 고려해야 한다.

| 구분      | 내용                                                         |
| --------- | ------------------------------------------------------------ |
| 가용성    | * 시스템의 장시간 운영으로 인해 발생할 수 있는 운영체제 고유의 장애 발생 가능성<br />* 메모리 누수로 인한 성능 저하 및 재가동<br />* 보안상 발견된 허점을 보완하기 위한 지속적인 패치 설치로 인한 재가동<br />* 운영체제의 결함 등으로 인한 패치 설치를 위한 재가동 |
| 성능      | * 대규모 동시 사용자 요청에 대한 처리<br />* 대규모 및 대용량 파일 작업에 대한 처리<br />* 지원 가능한 메모리 크기(32bit, 64bit) |
| 기술 지원 | * 제작업체의 안정적인 기술 지원<br />* 여러 사용자들 간의 정보 공유<br />* 오픈 소스 여부(Linux) |
| 주변 기기 | * 설치 가능한 하드웨어<br />* 여러 주변 기기 지원 여부       |
| 구축 비용 | * 지원 가능한 하드웨어 비용<br />* 설치할 응용 프로그램의 라이선스 정책 및 비용<br />* 유지관리 비용<br />* 총 소유 비용(TCO) |

### 4. 데이터베이스 관리 시스템(DBMS)

DBMS(DataBase Management System)는 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고, 데이터베이스를 관리해 주는 소프트웨어이다.

* DBMS는 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템으로, 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리해 준다.
* DBMS는 데이터베이스의 구성, 접근 방법, 유지관리에 대한 모든 책임을 진다.
* DBMS의 종류에는 Oracle, IBM, DB2, Microsoft SQL Server, MySQL, SQLite, MongoDB, Redis 등이 있다.

### 5. DBMS 관련 요구사항 식별 시 고려사항

DBMS와 관련된 요구사항 식별 시 다음과 같은 사항을 고려해야 한다.

| 구분        | 내용                                                         |
| ----------- | ------------------------------------------------------------ |
| 가용성      | * 시스템의 장시간 운영으로 인해 발생할 수 있는 운영체제 고유의 장애 발생 가능성<br />* DBMS의 결함 등으로 인해 패치 설치를 위한 재가동<br />* 백업이나 복구의 편의성<br />* DBMS 이중화 및 복제 지원 |
| 성능        | * 대규모 데이터 처리 성능(분할 테이블 지원 여부)<br />* 대용량 트랜잭션 처리 성능<br />* 튜닝 옵션의 다양한 지원<br />* 최소화된 설정과 비용 기반 질의 최적화 지원 |
| 기술 지원   | * 제작업체의 안정적인 기술 지원<br />* 여러 사용자들 간의 정보 공유<br />* 오픈 소스 여부 |
| 상호 호환성 | * 설치 가능한 운영체제의 종류<br />* JDBC, ODBC와의 호환 여부 |
| 구축 비용   | * 라이선스 정책 및 비용<br />* 유지관리 비용<br />* 총 소유 비용(TCO) |

### 6. 웹 어플리케이션 서버(WAS)

웹 어플리케이션 서번느 정적인 콘텐츠 처리를 하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어이다.

* 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리를 제공한다.
* 주로 데이터베이스 서버와 연동해서 사용한다.
* 웹 어플리케이션 서버의 종류에는 Tomcat, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere 등이 있다.

### 7. 웹 어플리케이션 서버(WAS) 관련 요구사항 식별 시 고려사항

웹 어플리케이션 서버(WAS)와 관련된 요구사항 식별 시 다음과 같은 사항을 고려해야 한다.

| 구분      | 내용                                                         |
| --------- | ------------------------------------------------------------ |
| 가용성    | * 시스템의 장시간 운영으로 인해 발생할 수 있는 고유의 장애 발생 가능성<br />* WAS의 결함 등으로 인한 패치 설치를 위한 재가동<br />* 안정적인 트랜잭션 처리<br />* WAS 이중화 지원 |
| 성능      | * 대규모 트랜잭션 처리 성능<br />* 다양한 설정 옵션 지원<br />* 가비지 컬랙션(GC)의 다양한 옵션 |
| 기술 지원 | * 제조업체의 안정적인 기술 지원<br />* 여러 사용자들 간의 정보 공유<br />* 오픈 소스 여부 |
| 구축 비용 | * 라이선스 정책 및 비용<br />* 유지관리 비용<br />* 총 소유 비용(TCO) |

## 6. 요구사항 정의

### 1. 요구사항의 개념 및 특징

요구사항은 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는 데 필요한 제약조건 등을 나타낸다.

* 요구사항은 소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공한다.
* 요구사항은 개발하려는 소프트웨어의 전반적인 내용을 확인할 수 힜게 하므로 개발에 참여하는 이해관계자들 간의 의사소통을 원활하게 하는 데 도움을 준다.
* 요구사항이 제대로 정의되어야만 이를 토대로 이후 과정의 목표와 계획을 수립할 수 있다.

### 2. 요구사항의 유형

요구사항은 일반적으로 기술하는 내용에 따라 기능 요구사항(Functional requirements)과 비기능 요구사항(Non-functional requirements)으로 구분하며, 기술 관점과 대상의 범위에 따라 시스템 요구사항(System requirements)과 사용자 요구사항(User requirements)으로 나눈다.

| 유형                                         | 내용                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| 기능 요구사항(Functional requirements)       | * 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항<br />* 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항<br />* 시스템이 반드시 수행해야 하는 기능<br />* 사용자가 시스템을 통해 제공받기를 원하는 기능 |
| 비기능 요구사항(Non-functional requirements) | * 시스템 장비 구성 요구사항 : 하드웨어, 소프트웨어, 네트워크 등의 시스템 장비 구성에 대한 요구사항<br />* 성능 요구사항 : 처리 속도 및 시간, 처리량, 동적ㆍ정적 적용량, 가용성 등 성능에 대한 요구사항<br />* 인터페이스 요구사항 : 시스템 인터페이스와 사용자 인터페이스에 대한 요구사항으로 다른 소프트웨어, 하드웨어 및 통신 인터페이스, 다른 시스템과의 정보 교환에 사용되는 프로토콜과의 연계도 포함하여 기술<br />* 데이터 요구사항 : 초기 자료 구축 및 데이터 변환을 위한 대상, 방법, 보안이 필요한 데이터 등 데이터를 구축하기 위해 필요한 요구사항<br />* 테스트 요구사항 : 도입되는 장비의 성능 테스트(BMT)나 구축된 시스템이 제대로 운영되는지를 테스트하고 점검하기 위한 테스트 요구사항<br />* 보안 요구사항 : 관리가 필요한 품질 항목, 품질 평가 대상에 대한 요구사항으로 가용성, 정합성, 상호 호환성, 대응성, 신뢰성, 사용성, 유지ㆍ관리성, 이식성, 확장성, 보안성 등으로 구분하여 기술<br />* 제약사항 : 시스템 설계 구축, 운영과 관련하여 사전에 파악된 기술, 표준, 업무법ㆍ제도 등의 제약조건<br />* 프로젝트 관리 요구사항 : 프로젝트의 원활한 수행을 위한 관리 방법에 대한 요구 사항<br />* 프로젝트 지원 요구사항 : 프로젝트의 원활한 수행을 위한 지원 사항이나 방안에 대한 요구사항 |
| 사용자 요구사항(User requirements)           | * 사용자 관점에서 본 시스템이 제공해야 할 요구사항<br />* 사용자를 위한 것으로 친숙한 표현으로 이해하기 쉽게 작성된다. |
| 시스템 요구사항(System requirements)         | * 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항<br />* 사용자 요구사항에 비해 전문적이고 기술적인 용어로 표현된다.<br />* 소프트웨어 요구사항이라고도 한다. |

### 3. 요구사항 개발 프로세스

요구사항 개발 프로세스는 개발 대상에 대한 요구사항을 체계적으로 도출하고 이를 분석한 후 분석 결과를 명세서(Specification Document)에 정리한 다음 마지막으로 이를 확인 및 검증하는 일련의 구조화된 활동이다.

* 요구사항 개발 프로세스가 진행되기 전에 개발 프로세스가 비즈니스 목적에 부합되는지, 예산은 적정한지 등에 대한 정보를 수집, 평가한 보고서를 토대로 타당성 조사(Feasibility Study)가 선행되어야 한다.
* 요구사항 개발은 요구공학(Requirements Engineering)의 한 요소이다.

도출(Elicitation) → 분석(Analysis) → 명세(Specification) → 확인(Validation)

※ cf) : 요구공학(Requirements Engineering)

요구공학은 무엇을 개발해야 하는지 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문이다.

* 점점 복잡하고 대형화되어가는 소프트웨어 개발환경에 따라 사용자 요구사항도 더욱 복잡해지고 잦은 변경이 발생하는 데, 이는 요구사항에 문제가 발생할 가능성을 높이며 요구사항 관리가 잘못될 수 있는 원인이 된다.
* 요구공학은 요구사항 변경의 원인과 처리 방법을 이해하고 요구사항 관리 프로세스의 품질을 개선하여 소프트웨어 프로젝트 실패를 최소화하는 것을 목표로 한다.

![image-20240420233832839](/home/oem/engineer_information_processing/assets/image-20240420233832839.png)

### 4. 요구사항 도출(Requirement Elicitation, 요구사항 수집)

요구사항 도출은 시스템, 사용자, 그리고 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항이 어디에 있는지, 어떻게 수집할 것인지를 식별하고 이해하는 과정이다.

* 요구사항 도출은 소프트웨어가 해결해야 할 문제를 이해하는 첫 번째 단계이다.
* 요구사항 도출 단꼐에서 개발좌와 고객 사이의 관계가 만들어지고 이해관계자(Stakeholder)가 식별된다.
* 이 단계에서는 다양한 이해관계자 간의 효율적인 의사소통이 중요하다.
* 요구사항 도출은 소프트웨어 개발 생명 주기(SDLC; Software Development Life Cycle) 동안 지속적으로 반복된다.
* 요구사항을 도출하는 주요 기법에는 청취와 인터뷰, 설문, 브레인스토밍, 워크샵, 포로토타이핑, 유스케이스 등이 있다.

### 5. 요구사항 분석(Requirement Analysis)

요구사항 분석은 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정이다.

* 사용자 요구사항의 타당성을 조사하고 비용과 일정에 대한 제약을 설정한다.
* 내용이 중복되거나 하나로 통합되어야 하는 등 서로 상충되는 요구사항이 있으면 이를 중재하는 과정이다.
* 도출된 요구사항들을 토대로 소프트웨어의 범위를 파악한다.
* 도출된 요구사항들을 토대로 소프트웨어와 주변 환경이 상호 작용하는 방법을 이해한다.
* 요구사항 분석에는 자료 흐름도(DFD), 자료 사전(DD) 등의 도구가 사용된다.

### 6. 요구사항 명세(Requirement Specification)

요구사항 명세는 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것을 의미한다.

* 요구사항을 문서화할 때는 기능 요구사항은 빠짐없이 관전하고 명확하게 기술해야 하며, 비기능 요구사항은 필요한 것만 명확하게 기술해야 한다.
* 요구사항은 사용자가 이해하기 쉬우며, 개발자가 효과적으로 설계할 수 있도록 작성되어야 한다.
* 설계 과정에서 잘못된 부분이 확인될 경우 그 내용을 요구사항 정의사에서 추적할 수 있어야 한다.
* 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 사용될 수 있다.

※ cf) : 소프트웨어 요구사항 명세서 / 요구사항 명세 기법

* 소프트웨어 요구사항 명세서(SRS; Software Requirement Specification)

  업계 표준 용어로 소프트웨어가 반드시 제공해야 하는 기능, 특징, 제약조건 등을 명시한다.

  * 시스템의 모든 동작 뿐만 아니라 성능, 보안, 사용성과 같은 품질도 기술되어야 한다.
  * 프로젝트 유형에 맞게 양식을 만들어 사용한다.
  * 소프트웨어 요구사항 명세서에 포함되는 시스템 기능, 데이터, 외부 인터페이스, 품질 요구사항은 요구사항 단위별로 개별 요구사항 명세서를 작성한다.

* 요구사항 명세 기법

  요구사항 명세 기법은 정형 명세와 비정형 명세로 구분된다.

  | 구분      | 정형 명세 기법                                               | 비정형 명세 기법                                             |
  | --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 기법      | 수학적 원리 기반, 모델 기반                                  | 상태 / 기능 / 객체 중심                                      |
  | 작성 방법 | 수학적 기호, 정형화된 표기법                                 | 일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성 |
  | 특징      | * 요구사항을 정확하고 간결하게 표현할 수 있음<br />* 요구사항에 대한 결과가 작성자에 관계없이 일관성이 있으므로 완전성 검증이 가능함<br />* 표기법이 어려워 사용자가 이해하기 어려움 | * 자연어의 사용으로 인해 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고, 해석이 달라질 수 있음<br />* 내용의 이해가 쉬워 의사소통이 용이함 |
  | 종류      | VDM, Z, Petri-net, CSP 등                                    | FSM, Decision Table, ER모델링, State Chart(SADT) 등          |

### 7. 요구사항 확인(Requirement Validation, 요구사항 검증)

요구사항 확인은 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동이다.

* 분석가가 요구사항을 정확하게 이해한 후 요구사항 명세서를 작성했는지 확인(Validation)하는 것이 필요하다.
* 요구사항 명세서의 내용이 이해하기 쉬운지, 일관성은 있는지, 회사의 기준에는 맞는지, 그리고 누락된 기능은 없는지 등을 검증(Verification)하는 것이 중요하다.
* 요구사항 문서는 이해관계자들이 검토해야 한다.
* 일반적으로 요구사항 관리 도구를 이용하여 요구사항 정의 문서들에 대해 형상 관리를 수행한다.

## 7. 요구사항 분석

### 1. 요구사항 분석의 개요

요구사항 분석은 소프트웨어 개발의 실제적인 첫 단계로 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화(명세화)하는 활동을 의미한다.

* 사용자의 요구의 타당성을 조사하고 비용과 일정에 대한 제약을 설정한다.
* 사용자의 요구를 정확하게 추출하여 목표를 정하고, 어떤 방식으로 해결할 것인지를 결정한다.
* 요구사항 분석을 통한 결과는 소프트웨어 설계 단꼐에서 필요한 기본적인 자료가 되므로 사용자의 요구사항을 정확하고 일관성 있게 분석하여 문서화해야 한다.
* 소프트웨어 분석가에 의해 요구사항 분석이 수행되며, 이 작업 단계를 요구사항 분석 단계라고 한다.

### 2. 구조적 분석 기법

구조적 분석 기법은 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법으로, 다음과 같은 특징이 있다.

* 도형 중심의 분석용 도구와 분석 절차를 이용하여 사용자의 요구사항을 파악하고 문서화한다.
* 도형 중심의 도구를 사용하므로 분석가와 사용자 간의 대화가 용이하다.
* 하향식 방법을 사용하여 시스템을 세분화할 수 있고, 분석의 중복을 배제할 수 있다.
* 사용자의 요구사항을 논리적으로 표현하여 전체 시스템을 일관성 잇게 이해할 수 있다.
* 시스템 분석의 질이 향상되고, 시스템 개발의 모든 단계에서 필요한 명세서 작성이 가능하다.
* 구조적 분석 기법에서는 자료 흐름도(DFD), 자료 사전(DD), 소단위 명세서(Mini-Spec.), 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서 등의 도구를 이용하여 모델링한다.

### 3. 자료 흐름도(DFD)

자료 흐름도(DFD; Data Flow Diagram)는 요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법으로 자료 흐름 그래프, 버블 차트라고도 한다.

* 시스템 안의 프로세스와 자료 저장소 사이에 자료의 흐름을 나타내는 그래프로 자료 흐름과 처리를 중심으로 하는 구조적 분석 기법에 이용된다.
* 자료 흐름도는 자료 흐름과 기능을 자세히 표현하기 위해 단계적으로 세분화된다.
* 자료는 처리(Process)를 거쳐 변환될 때마다 새로운 이름이 부여되며, 처리는 입력 자료가 발생하면 기능을 수행한 후 출력 자료를 산출한다.
* 자료 흐름도에서는 자료의 흐름과 기능을 프로세스(Process), 자료 흐름(Flow), 자료 저장소(Data Store), 단말(Terminator)의 네 가지 기본 기호로 표시한다.

![image-20240421142707530](/home/oem/engineer_information_processing/assets/image-20240421142707530.png)

### 4. 자료 사전

자료 사전(DD : Data Dictionary)은 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것이며, 이처럼 데이터를 설명하는 데이터를 데이터의 데이터 또는 메타 데이터(Meta Data)라고 한다.

* 자료 흐름도에 시각적으로 표시된 자료에 대한 정보를 체계적이고 조직적으로 모아 개발자나 사용자가 편리하게 사용할 수 있다.
* 자료 사전에서 사용되는 표기 기호는 다음과 같다.

| 기호 | 의미                                                         |
| ---- | ------------------------------------------------------------ |
| =    | 자료의 정의 : ~로 구성되어 있다(is composed of)              |
| +    | 자료의 연결 : 그리고(and)                                    |
| ( )  | 자료의 생각 : 생략 가능한 자료(Optional)                     |
| [\|] | 자료의 선택 : 또는(or)                                       |
| { }  | 자료의 반복 : Iteration of<br />(1) { }<sub>n</sub> : n번 이상 반복 (2) { }<sup>n</sup> : 최대로 n번 반복 (3) { }<sup>n</sup><sub>m</sub> : m 이상 n 이하로 반복 |
| * *  | 자료의 설명 : 주석(Comment)                                  |

## 8. 요구사항 분석 CASE와 HIPO

### 1. 요구사항 분석을 위한 CASE(자동화 도구)

* 요구사항 분석을 위한 자동화 도구는 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구를 의미한다.
* 요구사항 분석을 위한 자동화 도구 사용의 이점은 다음과 같다.
  * 표준화와 보고를 통한 문서화 품질 개선
  * 데이터베이스가 모두에게 이용 가능하다는 점을 분석자들 간의 적절한 조정
  * 교차 참조도와 보고서를 통한 결함, 생략, 불일치 등의 발견 용이성
  * 변경이 주는 영향 추적의 용이성
  * 명세에 대한 유지보수 비용의 축소

#### 종류

요구사항 분석을 위한 자동화 도구에는 SADT, SREM, PSL/PSA, TAGS, EPOS 등이 있다.

* SADT(Structured Analysis and Design Technique)

  * SoftTech 사에서 개발한 것으로 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설꼐를 위해 널리 이용되어 온 구조적 분석 및 설계 도구이다.
  * 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구이다.

* SREM(Software Requirements Engineering Methodology) = RSL/REVS

  * TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 것으로, RSL과 REVS를 사용하는 자동화 도구이다.

  * RSL(Requirement Statement Language)

    요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어

    ![image-20240421161902466](/home/oem/engineer_information_processing/assets/image-20240421161902466.png)

  * REVS(Requirement Engineering Validation System)

    RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기

* PSL/PSA

  * 미시간 대학에서 개발한 것으로 PSL과 PSA를 사용하는 자동화 도구이다.

  * PSL(Problem Statement Language)

    문제(요구사항) 기술 언어

  * PSA(Problem Statement Analyzer)

    PSL로 기술한 요구사항을 자동으로 분석하여 다양한 보고서를 출력하는 문제 분석기

* TAGS(Technology for Automated Generation of Systems)

  * 시스템 공학 방법 응용에 대한 자동 접근 방법으로, 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구이다.
  * 구성 : IORL, 요구사항 분석과 IORL 처리를 위한 도구, 기초적인 TAGS 방법론
  * IORL : 요구사항 명세 언어

### 2. HIPO

HIPO(Hierarchy Input Process Output)는 시스템의 분석 및 설계나 문서화할 때 사용되는 기법으로, 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타낸다.

* 기본 시스템 모델은 입력, 처리, 출력으로 구성되며, 하향식 소프트웨어 개발을 위한 문서화 도구이다.
* 체계적인 문서 관리가 가능하다.
* 기호, 도표 등을 사용하므로 보기 쉽고 이해하기도 쉽다.
* 기능과 자료의 의존 관계를 동시에 표현할 수 있다.
* 변경, 유지보수가 용이하다.
* 시스템의 기능을 여러 개의 고유 모듈들로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것을 HIPO Chart라고 한다.

#### HIPO Chart의 종류

HIPO Chart의 종류에서 가시적 도표(Visual Table of Contents), 총체적 도표(Overview Diagram), 세부적 도표(Detail Diagram)가 있다.

* 가시적 도표(도식 목차)

  시스템의 전체적인 기능과 흐름을 보여주는 계층(Tree) 구조도

* 총체적 도표(총괄 도표, 개요 도표)

  프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표

* 세부적 도표(상세 도표)

  총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

## 9. UML(Unified Modeling Language)

### 1. UML(Unified Modeling Language)

UML은 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어이다.

* UML은 Rumbaugh(OMT), Booch, Jacobson 등의 객체지향 방법론의 장점을 통합하였으며, 객체 기술에 관한 국제표준화기구인 OMG(Object Management Group)에서 표준으로 지정하였다.
* UML을 이용하여 시스템의 구조를 표현하는 6개의 구조 다이어그램과 시스템의 동작을 표현하는 7개의 행위 다이어그램을 작성할 수 있다.
* 각각의 다이어그램은 사물과 사물 간의 관계를 용도에 맞게 표현한다.
* UML의 구성 요소에는 사물(Things), 관계(Relationships), 다이어그램(Diagram) 등이 있다.

### 2. 사물(Things)

사물은 모델을 구성하는 가장 중요한 기본 요소로, 다이어그램 안에서 관계가 형성될 수 있는 대상들을 말한다.

* 사물에는 구조 사물, 행동 사물, 그룹 사물, 주해 사물이 있다.

| 사물                         | 내용                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 구조 사물(Structural Things) | * 시스템의 개념적, 물리적 요소를 표현<br />* 클래스(Class), 유스케이스(Use Case), 컴포넌트(Component), 노드(Node) 등 |
| 행동 사물(Behavioral Things) | * 시간과 공간에 따른 요소들의 행위를 표현<br />* 상호작용(Interaction), 상태 머신(State Machine) 등 |
| 그룹 사물(Grouping Things)   | * 요소들을 그룹으로 묶어서 표현<br />* 패키지(Package)       |
| 주해 사물(Annotation Things) | * 부가적인 설명이나 제약조건 등을 표현<br />* 노트(Note)     |

### 3. 관계(Relationships)

관계는 사물과 사물 사이의 연관성을 표현하는 것으로, 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계, 실체화 관계 등이 있다.

#### 연관(Association) 관계

연관 관계는 2개 이상의 사물이 서로 관련되어 있음을 표현한다.

* 사물 사이를 실선으로 연결하여 표현하며, 방향성은 화살표로 표현한다.

* 서로에게 영향을 주는 양방향 관계의 경우 화살표를 생략하고 실선으로만 연결한다.

* 연관에 참여하는 객체의 개수를 의미하는 다중도(Multiplicity)를 선 위에 표기한다.

  | 다중도      | 의미                                     |
  | ----------- | ---------------------------------------- |
  | 1           | 1개의 객체가 연관되어 있다.              |
  | n           | n개의 객체가 연관되어 있다.              |
  | 0..1        | 연관된 객체가 없거나 1개만 존재한다.     |
  | 0..* 또는 * | 연관된 객체가 없거나 다수일 수 있다.     |
  | 1..*        | 연관된 객체가 적어도 1개 이상이다.       |
  | n..*        | 연관된 객체가 적어도 n개 이상이다.       |
  | n..m        | 연관된 객체가 최소 n개에서 최대 m개이다. |

  ex 1) 사람이 집을 소유하는 관계이다. 사람은 자기가 소유하고 있는 집에 대해 알고 있지만 집은 누구에 의해 자신이 소유되고 있는지 모른다는 의미이다.

  ![image-20240421171639536](/home/oem/engineer_information_processing/assets/image-20240421171639536.png)

  해설)

  * '사람' 쪽에 표기된 다중도가 '1'이므로 집은 한 사람에 의해서만 소유될 수 있다.
  * '집' 쪽에 표기된 다중도가 '1'이므로 사람은 집을 하나만 소유할 수 있다.

  

  ex 2) 선생님은 학생을 가르치고 학생은 선생님으로부터 가르침을 받는 것과 같이 선생님과 학생은 서로 관계가 있다.

  ![image-20240421171944884](/home/oem/engineer_information_processing/assets/image-20240421171944884.png)

  해설)

  * '선생님' 쪽에 표기된 다중도가 '1..*'이므로 학생은 한 명 이상의 선생님으로부터 가르침을 받는다.
  * '학생' 쪽에 표기된 다중도가 '1..*'이므로 선생님은 한 명 이상의 학생을 가르친다.

#### 집합(Aggregation) 관계

집합 관계는 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현한다.

* 포함하는 쪽(전체, Whole)과 포함되는 쪽(부분, Part)은 서로 독립적이다.
* 포함되는 쪽(부분, Part)에서 포함하는 쪽(전체, Whole)으로 속이 빈 마름모를 연결하여 표현한다.

ex) 프린터는 컴퓨터에 연결해서 사용할 수 있으며, 다른 컴퓨터에 연결해서 사용할 수도 있다.

![image-20240421172517980](/home/oem/engineer_information_processing/assets/image-20240421172517980.png)

#### 포함(Composition) 관계

포함 관계는 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계로 표현한다.

* 포함하는 쪽(전체, Whole)과 포함되는 쪽(부분, Part)은 서로 독립될 수 없고 생명주기를 함께한다.
* 포함되는 쪽(부분, Part)에서 포함하는 쪽(전체, Whole)으로 속이 채워진 마름모를 연결하여 표현한다.

ex) 문을 열 수 있는 키는 하나이며, 해당 키로 다른 문은 열 수 없다. 문이 없어지면 키도 더 이상 필요하지 않다.

![image-20240421172743078](/home/oem/engineer_information_processing/assets/image-20240421172743078.png)

#### 일반화(Generalization) 관계

일반화 관계는 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현한다.

* 예를 들어 사람은 여자와 남자보다 일반적인 개념이고 반대로 여자와 남자는 사람보다 구체적인 개념이다.
* 보다 일반적인 개념을 상위(부모), 보다 구체적인 개념을 하위(자식)라고 부른다.
* 구체적(하위)인 사물에서 일반적(상위)인 사물 쪽으로 속이 빈 화살표를 연결하여 표현한다.

ex) 아메리카노와 에스프레소는 커피이다. 다시 말하면, 커피에는 아메리카노와 에스프레소가 있다.

![image-20240421173141317](/home/oem/engineer_information_processing/assets/image-20240421173141317.png)

#### 의존(Dependency) 관계

의존 관계는 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현한다.

* 하나의 사물과 다른 사물이 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계이다.
* 영향을 주는 사물(이용자)이 영향을 받는 사물(제공자) 쪽으로 점선 화살표를 연결하여 표현한다.

ex) 등급이 높으면 할인율을 적용하고, 등급이 낮으면 할인율을 적용하지 않는다.

![image-20240421173415465](/home/oem/engineer_information_processing/assets/image-20240421173415465.png)

#### 실체화(Realization) 관계

실체화 관계는 사물이 할 수 있거나 해야 하는 기능(행위, 인터페이스)으로 서로를 그룹화 할 수 있는 관계를 표현한다.

* 사물에서 기능 쪽으로 속이 빈 점선 화살표를 연결하여 표현한다.

ex) 비행기는 날 수 있고 새도 날 수 있다. 그러므로 비행기와 새는 날 수 있다는 행위로 그룹화 할 수 있다.

![image-20240421174332412](/home/oem/engineer_information_processing/assets/image-20240421174332412.png)

### 4. 다이어그램(Diagram)

다이어그램은 사물과 관계를 도형으로 표현한것이다.

* 여러 관점에서 시스템을 가시화한 뷰(View)를 제공함으로써 의사소통에 도움을 준다.

* 정적 모델링에서는 주로 구조적 다이어그램을 사용하고 동적 모델리에서는 주로 행위 다이어그램을 사용한다.

* 구조적(Structural) 다이어그램의 종류

  | 다이어그램                                              | 설명                                                         |
  | ------------------------------------------------------- | ------------------------------------------------------------ |
  | 클래스 다이어그램 (Class Diagram)                       | * 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한다. <br />* 시스템의 구조를 파악하고 구조상의 문제점을 도출할 수 있다. |
  | 객체 다이어그램 (Object Diagram)                        | * 클래스에 속한 사물(객체)들, 즉 인스턴스(instance)를 특정 시점의 객체와 객체 사이의 관계로 표현한다. <br />* 럼바우(Rumbaugh) 객체지향 분석 기법에서 객체 모델링에 활용된다. |
  | 컴포넌트 다이어그램 (Component Diagram)                 | * 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현한다. <br />* 구현 단계에서 사용되는 다이어그램이다. |
  | 배치 다이어그램 (Deployment Diagram)                    | * 결과물 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현한다. <br />* 노드와 의사소통(통신) 경로로 표현한다. * 구현 단계에서 사용되는 다이어그램이다. |
  | 복합체 구조 다이어그램 (Composite Structure Diagram)    | 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현한다. |
  | 패키지 다이어그램 (Package Diagram)                     | 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현한다. |
  | 유스케이스 다이어그램 (Use Case Diagram)                | * 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용한다. <br />* 사용자(Actor)와 사용 사례(Use Case)로 구성되며, 사용 사례 간에는 여러 형태의 관계로 이루어진다. |
  | 시퀀스 다이어그램 (Sequence Diagram)                    | 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현한다. |
  | 커뮤니케이션 다이어그램 (Communication Diagram)         | 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하는데, 메시지뿐만 아니라 객체들 간의 연관까지 표현한다. |
  | 상태 다이어그램 (State Diagram)                         | * 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현한다. <br />* 럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용된다. |
  | 활동 다이어그램 (Activity Diagram)                      | 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현한다. |
  | 상호작용 개요 다이어그램 (Interaction Overview Diagram) | 상호작용 다이어그램 간의 제어 흐름을 표현한다.               |
  | 타이밍 다이어그램 (Timing Diagram)                      | 객체 상태 변화와 시간 제약을 명시적으로 표현한다.            |

※ cf) : 스테레오 타입(Stereotype)

스테레오 타입은 UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용한다.

* 길러멧(Guilemet)이라고 부르는 겹화살괄효(<< >>) 사이에 표현할 형태를 기술한다.

* 주로 표현되는 형태는 다음과 같다.

  | 스테레오 타입   | 설명                                              |
  | --------------- | ------------------------------------------------- |
  | <<include>>     | 연결된 다른 UML 요소에 대해 포함 관계에 있는 경우 |
  | <<extend>>      | 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우 |
  | <<interface>>   | 인터페이스를 정의하는 경우                        |
  | <<exception>>   | 예외를 정의하는 경우                              |
  | <<constructor>> | 생성자 역할을 수행하는 경우                       |

## 10. 주요 UML 다이어그램

### 1. 유스케이스(Use Case) 다이어그램

유스케이스 다이어그램은 개발될 시스템과 관련된 외부 요소들, 즉 사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점(View)에서 표현한 것이다.

* 외부 요소와 시스템 간의 상호 작용을 확인할 수 있다.
* 사용자의 요구사항을 분석하기 위한 도구로 사용된다.
* 시스템의 범위를 파악할 수 있다.

#### 유스케이스 다이어그램의 구성 요소

유스케이스 다이어그램은 시스템 범위, 액터, 유스케이스, 관계로 구성된다.

| 구성 요소                                  | 설명                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| 시스템(System) / 시스템 범위(System Scope) | 시스템 내부에서 수행되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현함 |
| 액터(Actor)                                | * 시스템과 상호작용을 하는 모든 외부요소로, 사람이나 외부 시스템을 의미함<br />* 주액터 : 시스템을 사용함으로써 이득을 얻는 대상으로, 주로 사람이 해당함<br />* 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로, 조직이나 기관 등이 될 수 있음 |
| 유스케이스(Use Case)                       | 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현한 것 |
| 관계(Relationship)                         | 유스케이스 다이어그램에서 관계는 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있으며, 포함 관계, 확장 관계, 일반화 관계의 3종류가 있음 |

### 2. 클래스(Class) 다이어그램

클래스 다이어그램은 시스템을 구성하는 클래스, 클래스의 특성인 속성과 오퍼레이션, 속성과 오퍼레이션에 대한 제약조건, 클래스 사이의 관계를 표현한 것이다.

* 클래스 다이어그램은 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램이다.
* 클래스 다이어그램은 시스템 구성 요소를 문서화하는 데 사용된다.
* 코딩에 필요한 객체의 속성, 함수 등의 정보를 잘 표현하고 있어 시스템을 모델링하는 데 자주 사용된다.

#### 클래스 다이어그램의 구성 요소

클래스 다이어그램은 클래스, 제약조건, 관계 등으로 구성된다.

| 구성 요소           | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| 클래스(Class)       | * 클래스는 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현함<br />* 일반적으로 3개의 구획(Compartment)으로 나눠 클래스의 이름, 속성, 오퍼레이션을 표기함<br />* 속성(Attribute) : 클래스의 상태나 정보를 표현함<br />* 오퍼레이션(Operation) : 클래스가 수행할 수 있는 동작으로, 함수(메소드, Method)라고도 함 |
| 제약조건            | 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 적음 |
| 관계(Relationships) | * 관계는 클래스와 클래스 사이의 연관성을 표현함<br />* 클래스 다이어그램에 표현하는 관계에는 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계가 있음 |

※ cf) : 접근제어자

접근제어자는 속성과 오퍼레이션에 동일하게 적용되며, 표현법은 다음과 같다.

| 접근제어자 | 표현법 | 내용                                                         |
| ---------- | ------ | ------------------------------------------------------------ |
| public     | +      | 어떤 클래스에서라도 접근 가능                                |
| private    | -      | 해당 클래스 내부에서만 접근 가능                             |
| protected  | #      | 동일 패키지 내의 클래스 또는 해당 클래스를 상속 받는 외부 패키지의 클래스에서 접근 가능 |
| package    | ~      | 동일 패키지 내부에 있는 클래스에서만 접근 가능               |

### 3. 시퀀스(Sequence) 다이어그램

시퀀스 다이어그램은 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호 작용하는 과정을 액터, 객체, 메시지 등의 요소를 사용하여 그림으로 표현한 것이다.

* 시퀀스 다이어그램은 시스템이나 객체들의 상호 작용 과정에서 주고받는 메시지를 표현한다.
* 시퀀스 다이어그램을 통해 각 동작에 참여하는 시스템이나 객체들의 수행 기간을 확인할 수 있다.
* 시퀀스 다이어그램은 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호 작용을 표현한다.
* 시퀀스 다이어그램은 주로 기능 모델링에서 작성한 유스케이스 명세서를 하나의 표현 범위로 하지만, 하나의 클래스에 포함된 오퍼레이션을 하나의 범위로 표현하기도 한다.

#### 시퀀스 다이어그램의 구성 요소

시퀀스 다이어그램은 액터, 객체, 생명선, 실행, 메시지 등으로 구성된다.

| 구성 요소             | 내용                                                         |
| --------------------- | ------------------------------------------------------------ |
| 액터(Actor)           | 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미함 |
| 객체(Object)          | 메시지를 주고받는 주체                                       |
| 생명선(Lifeline)      | 객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 점선을 그어 표현함 |
| 실행 상자(Active Box) | 객체가 메시지를 주고받으며 구동되고 있음을 표현함            |
| 메시지(Message)       | 객체가 상호 작용을 위해 주고받는 메시지                      |





