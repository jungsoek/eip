# 1과목. 소프트웨어 설계

# 1장. 요구사항 확인

## 1. 소프트웨어 생명 주기

### 1. 소프트웨어 생명 주기(Software Life Cycle)

소프트웨어 생명 주기는 소프트웨어 개발 방법론의 바탕이 되는 것으로, 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계별로 나눈 것이다.

* 소프트웨어 생명 주기는 소프트웨어 개발 단계와 각 단계별 주요 활동, 그리고 활동의 결과에 대한 산출물로 표현한다. 소프트웨어 수명 주기로고도 한다.
* 소프트웨어 생명 주기를 표현하는 형태를 소프트웨어 생명 주기 모형이라고 하며, 스프트웨어 프로세스 모형 또는 소프트웨어 공학 패러다임이라고도 한다.
* 개발자는 문제의 유형이나 개발 방법 등에 따라 특정 모형을 선택하여 사용할 수도 있고, 개별적인 모형을 사용할 수도 있다.
* 일반적으로 사용되는 소프트웨어 생명 주기 모형에는 폭포수 모형, 프로토타입 모형, 나선형 모형, 에자일 모형 등이 있다.

※ cf) : 소프트웨어 공학

소프트웨어 공학의 개념

* 소프트웨어 공학(SE)은 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문이며 어러 가지 방법론과 도구, 관리 기법등을 통하여 소프트웨어의 품질과 생산성 향상을 목적으로 한다.

* 소프트웨어 공학은 다음과 같이 여러 형태로 정의할 수 있다.

  * IEEE의 소프트웨어 공학 표준 용어사전

    소프트웨어의 개발, 운용, 유지보수, 폐기 처분에 대한 체계적인 접근 방인

  * Fairley

    지정된 비용과 기간 내에 소프트웨어를 체계적으로 생선하고 유지보수하는 데 관련된 기술적이고 관리적인 원리

  * Boehm

    과학적인 지식을 소프트웨어 설계와 제작에 응용하는 것이며 이를 개발, 운용, 유지보수하는 데 필요한 문서 작성 과정

소프트웨어 공학의 기본 원칙

* 현대적인 프로그래밍 기술을 계속적으로 적용해야 한다.
* 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 한다.
* 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다.

### 2. 폭포수 모형(Waterfall Model)

폭포수 모형은 폭포에서 한번 떨어진 물은 거슬러 올라갈 수 없듯이 소프트웨어 개발도 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론이다.

* 폭포수 모형은 소프트웨어 공학에서 가장 오래되고 가장 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형으로, 고전적 생명 주기 모형이라고도 한다.
* 소프트웨어 개발 과정의 한 단계가 끝나야만 다음 단계로 넘어갈 수 잇는 선형 순차적 모형이다.
* 모형을 적용한 경험과 성공 사례가 많다.
* 제품의 일부가 될 메뉴얼을 작성해야 한다.
* 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 한다.
* 두 개 이상의 과정이 병행하여 수행되지 않는다.

`타당성 검토` → `계획` → `요구 분석` → `설계` → `구현(코딩)` → `시험(검사)` → `유지보수`

### 3. 프로토타입 모형(Prototype Model, 원형 모형)

프로토타입 모형은 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본(시제)품을 만들어 최종 결과물을 예측하는 모형이다.

* 시제품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발한다.
* 시스템의 일부 혹은 시스템의 모형을 만드는 과정으로서 요구된 소프트웨어를 구현하는데, 이는 추수 구현 단계에서 사용될 골격 코드가 된다.
* 소프트웨어의 개발이 완료된 시점에서 오류가 발견되는 폭포수 모형의 단점을 보완하기 위한 모형이다.

![img](https://blog.kakaocdn.net/dn/dz3YHR/btqBRwWn0OT/rsUdp0Pa5GgJKm3MLwaVmk/img.png)

### 나선형(Spiral Model, 점진적 모형)

나선형 모형은 보헴이 제안한 것으로, 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형이다.

* 나선을 따라 돌듯이 어러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벅한 최종 소프트웨어를 개발하는 것으로, 점진적 모형이라고도 한다.
* 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 한다.
* 점진적으로 개발 과정이 반복되므로 누락되거나 추가된 요구사항을 첨가할 수 있고, 정밀하며, 유지보수 과정이 필요 없다.

![나선형모델.png](https://itwiki.kr/images/2/2a/%EB%82%98%EC%84%A0%ED%98%95%EB%AA%A8%EB%8D%B8.png)

### 5. 애자일 모형(Agile Model)

애자일은 '민첩한'이라는 의미로, 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발과정을 진행한다.

* 애자일 모형은 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭한다.
* 애자일 모형은 기업 활동 전반에 걸쳐 사용된다.
* 애자일 모형은 스프린트 또는 이터레이션이라고 불리는 짧은 개발 주기를 반복하며, 반복하는 주기마다 만들어지는 결과물에 대한 고객의 평가와 요구를 수용한다.
* 각 개발주기에는 고객이 요구사항에 우선순위를 부여하여 개발 작업을 진행한다.
* 소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구사항에 적합하다.
* 애자일 모형을 기반으로 하는 소프트웨어 개발 모형에는 스크럼, XP, 칸반, Lean, 크리스탈, ASD, 기능 중심 개발, DSDM, DAD 등이 있다.

<img src="https://post-phinf.pstatic.net/MjAxODEwMDJfMTQg/MDAxNTM4NDQ5NzM1MTM5.BpLR3vJkFRD5OBMWcyXG1qlE0pMsRhafMIV8MssiY1gg.vuCWTel5XbZTtId_F-Lp3Rh_I2Ckw6DRsoX9shdGtDIg.PNG/%EC%95%A0%EC%9E%90%EC%9D%BC%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.png?type=w1200" alt="img" style="zoom:67%;" />

※ cf) : 애자일 선언(Agile Manifesto)

2001년 17명의 애자일 전문 개발자가 공통의 관점을 정리해 '애자일 SW 개발 선언문'을 만들었다. 선언문에는 애자일 개발 철학이 담겨있는 4가지 핵심 가치와 애자일 개발을 실무에 적용할 때 기준이 되는 12가지 실행 지침이 담겨있는데, 그 내용은 다음과 같다.

* 애자일 개발 4가지 핵심 가치
  1. 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.
  2. 방대한 문서보다는 실행되는 SW에 더 가치를 둔다.
  3. 계약 협상보다는 고객과 협업에 더 가치를 둔다.
  4. 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다.
* 애자일 개발 12가지 실행 지침
  1. 유용한 소프트웨어를 빠르고, 지속적으로 제공하여 고객을 만족시킨다.
  2. 개발 막바지라도 요구사항 변경을 적극 수용한다.
  3. 몇 개월이 아닌 몇 주 단위로 실행되는 소프트웨어를 제공한다.
  4. 고객과 개발자가 프로젝트 기간에 함께 일한다.
  5. 개발에 대한 참여 의지가 확실한 사람들로 팀을 구성하고, 필요한 개발 환경과 지원을 제공하며, 일을 잘 끝낼 수 있도록 신뢰한다.
  6. 같은 사무실에서 얼굴을 맞대고 의견을 나눈다.
  7. 개발의 진척도를 확인하는 1차 기준은 작동하는 소프트웨어이다.
  8. 지속 가능한 개발을 장려하고 일정한 속도로 개발을 진행한다.
  9. 기술적 우수성과 좋은 설계에 지속적인 관심을 기울이면 민첩성이 향상된다.
  10. 단순화를 추구한다.
  11. 최상의 아키텍쳐, 명확한 요구사항, 최상의 설계는 자기 스스로 일을 주도하는 조직적인 팀으로부터 나온다.
  12. 더 효과적인 팀이 될 수 있도록 방안을 정기적으로 깊이 고민하고 그에 따라 팀의 행동을 조정한다.

### 6. 폭포수 모형과 애자일의 비교

| 구분                 | 폭포수 모형                 | 애자일                                  |
| -------------------- | --------------------------- | --------------------------------------- |
| 새로운 요구사항 반영 | 어려움                      | 지속적으로 반영                         |
| 고객과의 의사소통    | 적음                        | 지속적임                                |
| 테스트               | 마지막에 모든 기능을 테스트 | 반복되는 일정 주기가 끝날 때마다 테스트 |
| 개발 중심            | 계획, 문서(메뉴얼)          | 고객                                    |

## 2. 스크럼(Scrum) 기법

### 1. 스크럼의 개요

스크럼이란 럭비에서 반칙으로 경기가 중단된 경우 양 팀의 선수들이 럭비공을 가운데 두고 상대팀을 밀치기 위해 서로 대치해 있는 대형을 말한다. 스크럼은 이처럼 팀이 중심이 되어 개발의 효율성을 높인다는 의미가 내포된 용어이다.

* 스크럼은 팀원 스스로가 스크럼 팀을 구성(self-organizing)해야 하며, 개발 작업에 관한 모든 것을 스스로 해결(cross-functional)할 수 있어야 한다.
* 스크럼 팀은 제품 책임자, 스크럼 마스터, 개발팀으로 구성된다.
  * 제품 책임자(PO; Product Owner)
    * 이해관계자들 중 개발될 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사 결정할 사람으로 선정하는데, 주로 개발 의뢰자나 사용자가 담당한다.
    * 이해관계자들의 의견을 종합하여 제품에 대한 요구사항을 작성하는 주체다.
    * 요구사항이 담긴 백로그(Backlog)를 작성하고 백로그에 대한 우선순위를 지정한다.
    * 팀원들이 백로그에 스토리를 추가할 수는 있지만 우선순위를 지정할 수는 없다.
    * 제품에 대한 테스트를 수행하면서 주기적으로 요구사항의 우선순위를 갱신한다.
  * 스크럼 마스터(SM; Scrum Master)
    * 스크럼 팀이 스크럼을 잘 수행할 수 있도록 객관적인 시각에서 조언을 해주는 가이드 역할을 수행한다. 팀원들을 통제하는 것이 목표가 아니다.
    * 일일 스크럼 회의를 주관하여 진행 사항을 점검하고, 개발 과정에서 발생된 장애 요소를 공론화하여 처리한다.
  * 개발팀(DT; Development Team)
    * 제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로, 개발자 외에도 디자이너, 테스터 등 제품 개발을 위해 참여하는 모든 사람이 대상이 된다.
    * 보통 최대 인원은 7 ~ 8명이 적당하다.

### 2. 스크럼 개발 프로세스

![img](https://velog.velcdn.com/images/octo__/post/0ba1ec28-0ed6-48fc-9814-111568f6a874/image.png)

* 제품 백로그(Product Backlog)
  * 제품 개발에 필요한 모든 요구사항(User Story)을 우선순위에 따라 나열한 목록이다.
  * 개발 과정에서 새롭게 도출되는 요구사항으로 인해 지속적으로 업데이트된다.
  * 제품 백로그에 작성된 사용자 스토리를 기반으로 전체 일정 계획인 릴리즈 계획(Release Plan)을 수립한다.
* 스프린트 계획 회의(Sprint Planning Meeting)
  * 제품 백로그 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립하는 것이다.
  * 스프린트에서 처리할 요구사항(User Story)을 개발자들이 나눠서 작업할 수 있도록 태스크(Task)라는 작업 단위로 분할한 후 개발자별로 수행할 작업 목록인 스프린트 백로그(Sprint Backlog)를 작성한다.
* 스프린트(Sprint)
  * 실제 개발 작업을 진행하는 과정으로, 보통 2-4주 정도의 기간 내에서 진행한다.
  * 스프린트 백로그에 작성된 태스크를 대상으로 작업 시간(양)을 추정한 후 개발 담당자에게 할당한다.
  * 태스크를 할당할 때는 개발자가 원하는 태스크를 직접 선별하여 담당할 수 있도록 하는 것이 좋다.
  * 개발 담당자에게 할당된 태스크는 보통 할 일(To Do), 진행 중(In Progress), 완료(Done)의 상태를 갖는다.
* 일일 스크럼 회의(Daily Scrum Meeting)
  * 모든 팀원이 매일 약속된 시간에 약 15분 정도의 짧은 시간동안 진행 상황을 점검한다.
  * 회의는 보통 서서 진행하며, 남은 작업 시간은 소멸 차트(Burn-down Chart)에 표시한다.
  * 스크럼 마스터는 발견된 장애 요소를 해결할 수 있도록 도와준다.
* 스프린트 검토 회의(Sprint Review)
  * 부분 또는 전체 완성 제품이 요구사항에 잘 부합되는지 사용자가 포함된 참석자 앞에서 테스팅을 수행한다.
  * 스프린트의 한 주당 한 시간 내에서 진행한다.
  * 제품 책임자(Product Owner)는 개선할 사항에 대한 피드백을 정리한 후 다음 스프린트에 반영할 수 있도록 제품 백로그를 업데이트한다.
* 스프린트 회고(Sprint Retrospective)
  * 스프린트 주기를 되돌아보며 정해놓은 규칙을 잘 준수했는지, 개선할 점은 없는지 등을 확인하고 기록한다.
  * 해당 스프린트가 끝난 시점에서 수행하거나 일정 주기로 수행한다.

## 3. XP(extreme programming) 기법

### 1. XP(extreme programming)

XP(extreme programming)는 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법이다.

* XP는 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.
* 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높인다.
* 릴리즈 테스트마다 고객을 직접 참여시킴으로써 요구한 기능이 제대로 작동하는지 고객이 직접 확인할 수 있다.
* 비교적 소규모 인원의 개발 프로젝트에 효과적이다.
* XP의 5가지 핵심 가치 : 의사소통(Communication), 단순성(Simplicity), 용기(Courage), 존중(Respect), 피드백(Feedback)

### XP 개발 프로세스

![img](https://notedailyit.co.kr/wp-content/uploads/2023/07/IMG_0875.png)

* 사용자 스토리(User Story)
  * 고객의 요구사항을 간단한 시나리오로 표현한 것이다.
  * 내용은 기능 단위로 구성하며, 필요한 경우 간단한 테스트 사항(Test Case)도 기재한다.
* 릴리즈 계획 수립(Release Planning)
  * 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것을 릴리즈라고 한다.
  * 부분 혹은 전체 개발 완료 시점에 대한 일정을 수립한다.
* 스파이크(Spike)
  * 요구사항의 신뢰성을 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램이다.
  * 처리할 문제 외의 다른 조건은 모두 무시하고 작성한다.
* 이터레이션(Iteration)
  * 하나의 릴리즈를 더 세분화 한 단위를 이터레이션(iteration)이라고 한다.
  * 일반적으로 1-3주 정도의 기간으로 진행된다.
  * 이 기간 중에 새로운 스토리가 작성될 수 있으며, 작성된 스토리는 진행 중인 이터레이션 혹은 다음 이터레이션에 포함될 수 있다.
* 승인 검사(Acceptance Test, 인수 테스트)
  * 하나의 이터레이션 안에서 계획된 릴리즈 단위의 부분 완료 제품이 구현되면 수행하는 테스트이다.
  * 사용자 스토리 작성 시 함께 기재한 테스트 사항에 대해 고객이 직접 수행한다.
  * 테스트 과정에서 발견한 오류 사항은 다음 이터레이션에 포함한다.
  * 테스트 이후 새로운 요구사항이 작성되거나 요구사항의 상대적 우선순위가 변경될 수 있다.
  * 테스트가 완료되면 다음 이터레이션을 진행한다.
* 소규모 릴리즈(Small Release)
  * 릴리즈를 소규모로 하게 되면, 고객의 반응을 기능별로 확인할 수 있어, 고객의 요구사항에 좀 더 유연하게 대응할 수 있다.
  * 계획된 릴리즈 기간 동안 진행된 이터레이션이 모두 완료되면 고객에 의한 최종 테스트를 수행한 후 릴리즈, 즉 최종 결과물을 고객에게 전달한다.
  * 릴리즈가 최종 완제품이 아닌 경우 다음 릴리즈 일정에 맞게 개발을 계속 진행한다.

※ cf) : XP의 주요 실천 방법(Practice)

| 실천 방법                                                  | 내용                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| Pair Programming(짝 프로그래밍)                            | 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성한다. |
| Collective Ownership(공동 코드 소유)                       | 개발 코드에 대한 권한과 책임을 공동으로 소유한다.            |
| Test-Driven Development(테스트 주도 개발)                  | * 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지 정확히 파악한다.<br />* 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구(구조, 프레임워크)를 사용한다. |
| Whole Team(전체 팀)                                        | 개발에 참여하는 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 한다. |
| Continuous Integration(지속적 통합)                        | 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합한다. |
| Design Improvement(디자인 개선) 또는 Refactoring(리팩토링) | 프로그램 기능의 변경 없이, 단순화, 유연성 강화 등을 통해 시스템을 재구성한다. |
| Small Release(소규모 릴리즈)                               | 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있다. |

## 4. 현행 시스템 파악

### 1. 현행 시스템 파악 절차

새로 개발하려는 시스템의 개발 범위를 명확히 설정하기 위해 현행 시스템의 구성과 제공 기능, 시스템 간의 전달 정보, 사용되는 기술 요소, 소프트웨어, 하드웨어, 그리고 네트워크의 구성 등을 파악한다.

![img](https://postfiles.pstatic.net/MjAyMDA0MTRfMjY4/MDAxNTg2ODMwODIxMDE0.QVDbBVZaU6FM3EAyXqaCI-iHKstz_3eFXFZdP2AujL0g.ELRBdQRKIliz7bAQbS75bbhcXhuDTmIQ-pJo0BVcYD0g.PNG.ehtm/image.png?type=w773)

### 2. 시스템 구성 파악

현행 시스템의 구성은 조직의 주요 업무를 담당하는 기간 업무와 이를 지원하는 지원 업무로 구분하여 기술한다.

* 조직 내에 있는 모든 정보시스템의 현황을 파악할 수 있도록 각 업무에 속하는 단위 업무 정보시스템들의 명칭, 주요 기능들을 명시한다.

ex) 금융 기관의 여신관리 업무와 고객관리 업무 시스템 현황

![image-20240420210110159](/home/oem/engineer_information_processing/assets/image-20240420210110159.png)

### 3. 시스템 기능 파악

현행 시스템의 기능은 단위 업무 시스템이 현재 제공하는 기능들을 주요 기능과 하부 기능, 세부 기능으로 구분하여 계층형으로 표시한다.

ex) 여신상담 관리 시스템의 주요 기능과 하부, 세부 기능

![image-20240420211216076](/home/oem/engineer_information_processing/assets/image-20240420211216076.png)

### 4. 시스템 인터페이스 파악

현행 시스템의 인터페이스에는 단위 업무 시스템 간에 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시한다.

* 데이터를 어떤 형식으로 주고받는지, 통신규약은 무엇을 사용하는지, 연계 유형은 무엇인지 등을 반드시 고려해야 한다.

ex) 여신상담 관리 시스템의 인터페이스 현황

![image-20240420211346010](/home/oem/engineer_information_processing/assets/image-20240420211346010.png)

### 5. 아키텍처 구성 파악

현행 시스템의 아키텍처 구성은 기간 업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성한다.

* 아키텍처가 단위 업무 시스템별로 다른 경우에는 가장 핵심이 되는 기간 업무 처리 시스템을 기준으로 표현한다.

ex) 회원 정보 관리 시스템 아키텍처 구성도

![img](https://funyphp.com/data/editor/2102/20210201161357_1f1380483b5909dcd774d7be2b351af2_sz48.png)

### 6. 소프트웨어 구성 파악

소프트웨어 구성에는 단위 업무 시스템별로 업무 처리를 위해 설치되어 있는 소프트웨어들의 제품명, 용도, 라이선스 적용 방식, 라이언스 수 등을 명시한다.

* 시스템 구축비용 면에서 소프트웨어 비용이 적지 않은 비중을 차지하므로, 상용 소프트웨어의 경우 라이선스 적용 방식의 기준과 보유한 라이선스의 파악이 중요하다.

ex) 단위 업무 시스템별 소프트웨어 현황

![image-20240420223734548](/home/oem/engineer_information_processing/assets/image-20240420223734548.png)

### 7. 하드웨어 구성 파악

하드웨어 구성에는 단위 업무 시스템들이 운용되는 서버의 주요 사항과 수량, 그리고 이중화의 적용 여부를 명시한다. 

* 서버의 이중화는 기간 업무의 서비스 기간, 장애 대응 정책에 따라 필요 여부가 결정된다.
* 현행 시스템에 이중화가 적용된 경우 대부분 새로 구성될 시스템에도 이중화가 필요하므로 이로 인한 비용 증가와 시스템 구축 난이도가 높아질 가능성을 고려해야 한다.

ex) 단위 업무 시스템별 하드웨어 현황

![image-20240420224845831](/home/oem/engineer_information_processing/assets/image-20240420224845831.png)

### 8. 네트워크 구성 파악

네트워크 구성은 업무 시스템들의 네트워크 구성을 파악할 수 있도록 서버의 위치, 서버 간의 네트워크 연결 방식을 네트워크 구성도로 작성한다.

* 네트워크 구성도를 통해 서버들의 물리적인 위치 관계를 파악할 수 있고 보안 취약성을 분석하여 적절한 대응을 할 수 있다.
* 네트워크에 장애가 발생한 경우 발생 원인을 찾아 복구하기 위한 용도로 활용될 수 있다.

ex) 자원관리팀, 마케팅팀, 업무 지원팀의 인터넷 접속을 위한 네트워크 구성도

![img](https://velog.velcdn.com/images/esjw_/post/7004b81d-fbbc-4310-bf2c-e1d1e6ee3773/image.png)

## 5. 개발 기술 환경 파악

### 1. 개발 기술 환경의 정의

개발하고자 하는 소프트웨어와 관련된 운영체제(OS), 데이터베이스 관리 시스템(DBMS), 미들웨어(Middle Ware) 등을 선정할 때 고려해야 할 사항을 기술하고, 오픈 소스 사용 시 주의해야 할 내용을 제시한다.

### 2. 운영체제(OS)

운영체제는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어이다.

* 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공해준다.
* 컴퓨터 운영체제의 종류에는 Windows, UNIX, Linux, Mac OS 등이, 모바일 운영체제에는 iOS, Android 등이 있다.

### 3. 운영체제 관련 요구사항 식별 시 고려사항

운영체제와 관련된 요구사항 식별 시 다음과 같은 사항을 고려해야 한다.

| 구분      | 내용                                                         |
| --------- | ------------------------------------------------------------ |
| 가용성    | * 시스템의 장시간 운영으로 인해 발생할 수 있는 운영체제 고유의 장애 발생 가능성<br />* 메모리 누수로 인한 성능 저하 및 재가동<br />* 보안상 발견된 허점을 보완하기 위한 지속적인 패치 설치로 인한 재가동<br />* 운영체제의 결함 등으로 인한 패치 설치를 위한 재가동 |
| 성능      | * 대규모 동시 사용자 요청에 대한 처리<br />* 대규모 및 대용량 파일 작업에 대한 처리<br />* 지원 가능한 메모리 크기(32bit, 64bit) |
| 기술 지원 | * 제작업체의 안정적인 기술 지원<br />* 여러 사용자들 간의 정보 공유<br />* 오픈 소스 여부(Linux) |
| 주변 기기 | * 설치 가능한 하드웨어<br />* 여러 주변 기기 지원 여부       |
| 구축 비용 | * 지원 가능한 하드웨어 비용<br />* 설치할 응용 프로그램의 라이선스 정책 및 비용<br />* 유지관리 비용<br />* 총 소유 비용(TCO) |

### 4. 데이터베이스 관리 시스템(DBMS)

DBMS(DataBase Management System)는 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고, 데이터베이스를 관리해 주는 소프트웨어이다.

* DBMS는 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템으로, 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리해 준다.
* DBMS는 데이터베이스의 구성, 접근 방법, 유지관리에 대한 모든 책임을 진다.
* DBMS의 종류에는 Oracle, IBM, DB2, Microsoft SQL Server, MySQL, SQLite, MongoDB, Redis 등이 있다.

### 5. DBMS 관련 요구사항 식별 시 고려사항

DBMS와 관련된 요구사항 식별 시 다음과 같은 사항을 고려해야 한다.

| 구분        | 내용                                                         |
| ----------- | ------------------------------------------------------------ |
| 가용성      | * 시스템의 장시간 운영으로 인해 발생할 수 있는 운영체제 고유의 장애 발생 가능성<br />* DBMS의 결함 등으로 인해 패치 설치를 위한 재가동<br />* 백업이나 복구의 편의성<br />* DBMS 이중화 및 복제 지원 |
| 성능        | * 대규모 데이터 처리 성능(분할 테이블 지원 여부)<br />* 대용량 트랜잭션 처리 성능<br />* 튜닝 옵션의 다양한 지원<br />* 최소화된 설정과 비용 기반 질의 최적화 지원 |
| 기술 지원   | * 제작업체의 안정적인 기술 지원<br />* 여러 사용자들 간의 정보 공유<br />* 오픈 소스 여부 |
| 상호 호환성 | * 설치 가능한 운영체제의 종류<br />* JDBC, ODBC와의 호환 여부 |
| 구축 비용   | * 라이선스 정책 및 비용<br />* 유지관리 비용<br />* 총 소유 비용(TCO) |

### 6. 웹 어플리케이션 서버(WAS)

웹 어플리케이션 서버는 정적인 콘텐츠 처리를 하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어이다.

* 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리를 제공한다.
* 주로 데이터베이스 서버와 연동해서 사용한다.
* 웹 어플리케이션 서버의 종류에는 Tomcat, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere 등이 있다.

### 7. 웹 어플리케이션 서버(WAS) 관련 요구사항 식별 시 고려사항

웹 어플리케이션 서버(WAS)와 관련된 요구사항 식별 시 다음과 같은 사항을 고려해야 한다.

| 구분      | 내용                                                         |
| --------- | ------------------------------------------------------------ |
| 가용성    | * 시스템의 장시간 운영으로 인해 발생할 수 있는 고유의 장애 발생 가능성<br />* WAS의 결함 등으로 인한 패치 설치를 위한 재가동<br />* 안정적인 트랜잭션 처리<br />* WAS 이중화 지원 |
| 성능      | * 대규모 트랜잭션 처리 성능<br />* 다양한 설정 옵션 지원<br />* 가비지 컬랙션(GC)의 다양한 옵션 |
| 기술 지원 | * 제조업체의 안정적인 기술 지원<br />* 여러 사용자들 간의 정보 공유<br />* 오픈 소스 여부 |
| 구축 비용 | * 라이선스 정책 및 비용<br />* 유지관리 비용<br />* 총 소유 비용(TCO) |

## 6. 요구사항 정의

### 1. 요구사항의 개념 및 특징

요구사항은 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는 데 필요한 제약조건 등을 나타낸다.

* 요구사항은 소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공한다.
* 요구사항은 개발하려는 소프트웨어의 전반적인 내용을 확인할 수 힜게 하므로 개발에 참여하는 이해관계자들 간의 의사소통을 원활하게 하는 데 도움을 준다.
* 요구사항이 제대로 정의되어야만 이를 토대로 이후 과정의 목표와 계획을 수립할 수 있다.

### 2. 요구사항의 유형

요구사항은 일반적으로 기술하는 내용에 따라 기능 요구사항(Functional requirements)과 비기능 요구사항(Non-functional requirements)으로 구분하며, 기술 관점과 대상의 범위에 따라 시스템 요구사항(System requirements)과 사용자 요구사항(User requirements)으로 나눈다.

| 유형                                         | 내용                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| 기능 요구사항(Functional requirements)       | * 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항<br />* 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지, 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항<br />* 시스템이 반드시 수행해야 하는 기능<br />* 사용자가 시스템을 통해 제공받기를 원하는 기능 |
| 비기능 요구사항(Non-functional requirements) | * 시스템 장비 구성 요구사항 : 하드웨어, 소프트웨어, 네트워크 등의 시스템 장비 구성에 대한 요구사항<br />* 성능 요구사항 : 처리 속도 및 시간, 처리량, 동적ㆍ정적 적용량, 가용성 등 성능에 대한 요구사항<br />* 인터페이스 요구사항 : 시스템 인터페이스와 사용자 인터페이스에 대한 요구사항으로 다른 소프트웨어, 하드웨어 및 통신 인터페이스, 다른 시스템과의 정보 교환에 사용되는 프로토콜과의 연계도 포함하여 기술<br />* 데이터 요구사항 : 초기 자료 구축 및 데이터 변환을 위한 대상, 방법, 보안이 필요한 데이터 등 데이터를 구축하기 위해 필요한 요구사항<br />* 테스트 요구사항 : 도입되는 장비의 성능 테스트(BMT)나 구축된 시스템이 제대로 운영되는지를 테스트하고 점검하기 위한 테스트 요구사항<br />* 보안 요구사항 : 관리가 필요한 품질 항목, 품질 평가 대상에 대한 요구사항으로 가용성, 정합성, 상호 호환성, 대응성, 신뢰성, 사용성, 유지ㆍ관리성, 이식성, 확장성, 보안성 등으로 구분하여 기술<br />* 제약사항 : 시스템 설계 구축, 운영과 관련하여 사전에 파악된 기술, 표준, 업무법ㆍ제도 등의 제약조건<br />* 프로젝트 관리 요구사항 : 프로젝트의 원활한 수행을 위한 관리 방법에 대한 요구 사항<br />* 프로젝트 지원 요구사항 : 프로젝트의 원활한 수행을 위한 지원 사항이나 방안에 대한 요구사항 |
| 사용자 요구사항(User requirements)           | * 사용자 관점에서 본 시스템이 제공해야 할 요구사항<br />* 사용자를 위한 것으로 친숙한 표현으로 이해하기 쉽게 작성된다. |
| 시스템 요구사항(System requirements)         | * 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항<br />* 사용자 요구사항에 비해 전문적이고 기술적인 용어로 표현된다.<br />* 소프트웨어 요구사항이라고도 한다. |

### 3. 요구사항 개발 프로세스

요구사항 개발 프로세스는 개발 대상에 대한 요구사항을 체계적으로 도출하고 이를 분석한 후 분석 결과를 명세서(Specification Document)에 정리한 다음 마지막으로 이를 확인 및 검증하는 일련의 구조화된 활동이다.

* 요구사항 개발 프로세스가 진행되기 전에 개발 프로세스가 비즈니스 목적에 부합되는지, 예산은 적정한지 등에 대한 정보를 수집, 평가한 보고서를 토대로 타당성 조사(Feasibility Study)가 선행되어야 한다.
* 요구사항 개발은 요구공학(Requirements Engineering)의 한 요소이다.

`도출(Elicitation)` → `분석(Analysis)` → `명세(Specification)` → `확인(Validation)`

※ cf) : 요구공학(Requirements Engineering)

요구공학은 무엇을 개발해야 하는지 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문이다.

* 점점 복잡하고 대형화되어가는 소프트웨어 개발환경에 따라 사용자 요구사항도 더욱 복잡해지고 잦은 변경이 발생하는 데, 이는 요구사항에 문제가 발생할 가능성을 높이며 요구사항 관리가 잘못될 수 있는 원인이 된다.
* 요구공학은 요구사항 변경의 원인과 처리 방법을 이해하고 요구사항 관리 프로세스의 품질을 개선하여 소프트웨어 프로젝트 실패를 최소화하는 것을 목표로 한다.

![image-20240420233832839](/home/oem/engineer_information_processing/assets/image-20240420233832839.png)

### 4. 요구사항 도출(Requirement Elicitation, 요구사항 수집)

요구사항 도출은 시스템, 사용자, 그리고 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항이 어디에 있는지, 어떻게 수집할 것인지를 식별하고 이해하는 과정이다.

* 요구사항 도출은 소프트웨어가 해결해야 할 문제를 이해하는 첫 번째 단계이다.
* 요구사항 도출 단꼐에서 개발좌와 고객 사이의 관계가 만들어지고 이해관계자(Stakeholder)가 식별된다.
* 이 단계에서는 다양한 이해관계자 간의 효율적인 의사소통이 중요하다.
* 요구사항 도출은 소프트웨어 개발 생명 주기(SDLC; Software Development Life Cycle) 동안 지속적으로 반복된다.
* 요구사항을 도출하는 주요 기법에는 청취와 인터뷰, 설문, 브레인스토밍, 워크샵, 포로토타이핑, 유스케이스 등이 있다.

### 5. 요구사항 분석(Requirement Analysis)

요구사항 분석은 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정이다.

* 사용자 요구사항의 타당성을 조사하고 비용과 일정에 대한 제약을 설정한다.
* 내용이 중복되거나 하나로 통합되어야 하는 등 서로 상충되는 요구사항이 있으면 이를 중재하는 과정이다.
* 도출된 요구사항들을 토대로 소프트웨어의 범위를 파악한다.
* 도출된 요구사항들을 토대로 소프트웨어와 주변 환경이 상호 작용하는 방법을 이해한다.
* 요구사항 분석에는 자료 흐름도(DFD), 자료 사전(DD) 등의 도구가 사용된다.

### 6. 요구사항 명세(Requirement Specification)

요구사항 명세는 분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것을 의미한다.

* 요구사항을 문서화할 때는 기능 요구사항은 빠짐없이 관전하고 명확하게 기술해야 하며, 비기능 요구사항은 필요한 것만 명확하게 기술해야 한다.
* 요구사항은 사용자가 이해하기 쉬우며, 개발자가 효과적으로 설계할 수 있도록 작성되어야 한다.
* 설계 과정에서 잘못된 부분이 확인될 경우 그 내용을 요구사항 정의사에서 추적할 수 있어야 한다.
* 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 사용될 수 있다.

※ cf) : 소프트웨어 요구사항 명세서 / 요구사항 명세 기법

* 소프트웨어 요구사항 명세서(SRS; Software Requirement Specification)

  업계 표준 용어로 소프트웨어가 반드시 제공해야 하는 기능, 특징, 제약조건 등을 명시한다.

  * 시스템의 모든 동작 뿐만 아니라 성능, 보안, 사용성과 같은 품질도 기술되어야 한다.
  * 프로젝트 유형에 맞게 양식을 만들어 사용한다.
  * 소프트웨어 요구사항 명세서에 포함되는 시스템 기능, 데이터, 외부 인터페이스, 품질 요구사항은 요구사항 단위별로 개별 요구사항 명세서를 작성한다.

* 요구사항 명세 기법

  요구사항 명세 기법은 정형 명세와 비정형 명세로 구분된다.

  | 구분      | 정형 명세 기법                                               | 비정형 명세 기법                                             |
  | --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 기법      | 수학적 원리 기반, 모델 기반                                  | 상태 / 기능 / 객체 중심                                      |
  | 작성 방법 | 수학적 기호, 정형화된 표기법                                 | 일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성 |
  | 특징      | * 요구사항을 정확하고 간결하게 표현할 수 있음<br />* 요구사항에 대한 결과가 작성자에 관계없이 일관성이 있으므로 완전성 검증이 가능함<br />* 표기법이 어려워 사용자가 이해하기 어려움 | * 자연어의 사용으로 인해 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고, 해석이 달라질 수 있음<br />* 내용의 이해가 쉬워 의사소통이 용이함 |
  | 종류      | VDM, Z, Petri-net, CSP 등                                    | FSM, Decision Table, ER모델링, State Chart(SADT) 등          |

### 7. 요구사항 확인(Requirement Validation, 요구사항 검증)

요구사항 확인은 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동이다.

* 분석가가 요구사항을 정확하게 이해한 후 요구사항 명세서를 작성했는지 확인(Validation)하는 것이 필요하다.
* 요구사항 명세서의 내용이 이해하기 쉬운지, 일관성은 있는지, 회사의 기준에는 맞는지, 그리고 누락된 기능은 없는지 등을 검증(Verification)하는 것이 중요하다.
* 요구사항 문서는 이해관계자들이 검토해야 한다.
* 일반적으로 요구사항 관리 도구를 이용하여 요구사항 정의 문서들에 대해 형상 관리를 수행한다.

## 7. 요구사항 분석

### 1. 요구사항 분석의 개요

요구사항 분석은 소프트웨어 개발의 실제적인 첫 단계로 개발 대상에 대한 사용자의 요구사항을 이해하고 문서화(명세화)하는 활동을 의미한다.

* 사용자의 요구의 타당성을 조사하고 비용과 일정에 대한 제약을 설정한다.
* 사용자의 요구를 정확하게 추출하여 목표를 정하고, 어떤 방식으로 해결할 것인지를 결정한다.
* 요구사항 분석을 통한 결과는 소프트웨어 설계 단꼐에서 필요한 기본적인 자료가 되므로 사용자의 요구사항을 정확하고 일관성 있게 분석하여 문서화해야 한다.
* 소프트웨어 분석가에 의해 요구사항 분석이 수행되며, 이 작업 단계를 요구사항 분석 단계라고 한다.

### 2. 구조적 분석 기법

구조적 분석 기법은 자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법으로, 다음과 같은 특징이 있다.

* 도형 중심의 분석용 도구와 분석 절차를 이용하여 사용자의 요구사항을 파악하고 문서화한다.
* 도형 중심의 도구를 사용하므로 분석가와 사용자 간의 대화가 용이하다.
* 하향식 방법을 사용하여 시스템을 세분화할 수 있고, 분석의 중복을 배제할 수 있다.
* 사용자의 요구사항을 논리적으로 표현하여 전체 시스템을 일관성 잇게 이해할 수 있다.
* 시스템 분석의 질이 향상되고, 시스템 개발의 모든 단계에서 필요한 명세서 작성이 가능하다.
* 구조적 분석 기법에서는 자료 흐름도(DFD), 자료 사전(DD), 소단위 명세서(Mini-Spec.), 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서 등의 도구를 이용하여 모델링한다.

### 3. 자료 흐름도(DFD)

자료 흐름도(DFD; Data Flow Diagram)는 요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법으로 자료 흐름 그래프, 버블 차트라고도 한다.

* 시스템 안의 프로세스와 자료 저장소 사이에 자료의 흐름을 나타내는 그래프로 자료 흐름과 처리를 중심으로 하는 구조적 분석 기법에 이용된다.
* 자료 흐름도는 자료 흐름과 기능을 자세히 표현하기 위해 단계적으로 세분화된다.
* 자료는 처리(Process)를 거쳐 변환될 때마다 새로운 이름이 부여되며, 처리는 입력 자료가 발생하면 기능을 수행한 후 출력 자료를 산출한다.
* 자료 흐름도에서는 자료의 흐름과 기능을 프로세스(Process), 자료 흐름(Flow), 자료 저장소(Data Store), 단말(Terminator)의 네 가지 기본 기호로 표시한다.

![image-20240421142707530](/home/oem/engineer_information_processing/assets/image-20240421142707530.png)

### 4. 자료 사전

자료 사전(DD : Data Dictionary)은 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것이며, 이처럼 데이터를 설명하는 데이터를 데이터의 데이터 또는 메타 데이터(Meta Data)라고 한다.

* 자료 흐름도에 시각적으로 표시된 자료에 대한 정보를 체계적이고 조직적으로 모아 개발자나 사용자가 편리하게 사용할 수 있다.
* 자료 사전에서 사용되는 표기 기호는 다음과 같다.

| 기호 | 의미                                                         |
| ---- | ------------------------------------------------------------ |
| =    | 자료의 정의 : ~로 구성되어 있다(is composed of)              |
| +    | 자료의 연결 : 그리고(and)                                    |
| ( )  | 자료의 생각 : 생략 가능한 자료(Optional)                     |
| [\|] | 자료의 선택 : 또는(or)                                       |
| { }  | 자료의 반복 : Iteration of<br />(1) { }<sub>n</sub> : n번 이상 반복 (2) { }<sup>n</sup> : 최대로 n번 반복 (3) { }<sup>n</sup><sub>m</sub> : m 이상 n 이하로 반복 |
| * *  | 자료의 설명 : 주석(Comment)                                  |

## 8. 요구사항 분석 CASE와 HIPO

### 1. 요구사항 분석을 위한 CASE(자동화 도구)

* 요구사항 분석을 위한 자동화 도구는 요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구를 의미한다.
* 요구사항 분석을 위한 자동화 도구 사용의 이점은 다음과 같다.
  * 표준화와 보고를 통한 문서화 품질 개선
  * 데이터베이스가 모두에게 이용 가능하다는 점을 분석자들 간의 적절한 조정
  * 교차 참조도와 보고서를 통한 결함, 생략, 불일치 등의 발견 용이성
  * 변경이 주는 영향 추적의 용이성
  * 명세에 대한 유지보수 비용의 축소

#### 종류

요구사항 분석을 위한 자동화 도구에는 SADT, SREM, PSL/PSA, TAGS, EPOS 등이 있다.

* SADT(Structured Analysis and Design Technique)

  * SoftTech 사에서 개발한 것으로 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설꼐를 위해 널리 이용되어 온 구조적 분석 및 설계 도구이다.
  * 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구이다.

* SREM(Software Requirements Engineering Methodology) = RSL/REVS

  * TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구사항을 명확히 기술하도록 할 목적으로 개발한 것으로, RSL과 REVS를 사용하는 자동화 도구이다.

  * RSL(Requirement Statement Language)

    요소, 속성, 관계, 구조들을 기술하는 요구사항 기술 언어

    ![image-20240421161902466](/home/oem/engineer_information_processing/assets/image-20240421161902466.png)

  * REVS(Requirement Engineering Validation System)

    RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분석 명세서를 출력하는 요구사항 분석기

* PSL/PSA

  * 미시간 대학에서 개발한 것으로 PSL과 PSA를 사용하는 자동화 도구이다.

  * PSL(Problem Statement Language)

    문제(요구사항) 기술 언어

  * PSA(Problem Statement Analyzer)

    PSL로 기술한 요구사항을 자동으로 분석하여 다양한 보고서를 출력하는 문제 분석기

* TAGS(Technology for Automated Generation of Systems)

  * 시스템 공학 방법 응용에 대한 자동 접근 방법으로, 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구이다.
  * 구성 : IORL, 요구사항 분석과 IORL 처리를 위한 도구, 기초적인 TAGS 방법론
  * IORL : 요구사항 명세 언어

### 2. HIPO

HIPO(Hierarchy Input Process Output)는 시스템의 분석 및 설계나 문서화할 때 사용되는 기법으로, 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타낸다.

* 기본 시스템 모델은 입력, 처리, 출력으로 구성되며, 하향식 소프트웨어 개발을 위한 문서화 도구이다.
* 체계적인 문서 관리가 가능하다.
* 기호, 도표 등을 사용하므로 보기 쉽고 이해하기도 쉽다.
* 기능과 자료의 의존 관계를 동시에 표현할 수 있다.
* 변경, 유지보수가 용이하다.
* 시스템의 기능을 여러 개의 고유 모듈들로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것을 HIPO Chart라고 한다.

#### HIPO Chart의 종류

HIPO Chart의 종류에서 가시적 도표(Visual Table of Contents), 총체적 도표(Overview Diagram), 세부적 도표(Detail Diagram)가 있다.

* 가시적 도표(도식 목차)

  시스템의 전체적인 기능과 흐름을 보여주는 계층(Tree) 구조도

* 총체적 도표(총괄 도표, 개요 도표)

  프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표

* 세부적 도표(상세 도표)

  총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

## 9. UML(Unified Modeling Language)

### 1. UML(Unified Modeling Language)

UML은 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어이다.

* UML은 Rumbaugh(OMT), Booch, Jacobson 등의 객체지향 방법론의 장점을 통합하였으며, 객체 기술에 관한 국제표준화기구인 OMG(Object Management Group)에서 표준으로 지정하였다.
* UML을 이용하여 시스템의 구조를 표현하는 6개의 구조 다이어그램과 시스템의 동작을 표현하는 7개의 행위 다이어그램을 작성할 수 있다.
* 각각의 다이어그램은 사물과 사물 간의 관계를 용도에 맞게 표현한다.
* UML의 구성 요소에는 사물(Things), 관계(Relationships), 다이어그램(Diagram) 등이 있다.

### 2. 사물(Things)

사물은 모델을 구성하는 가장 중요한 기본 요소로, 다이어그램 안에서 관계가 형성될 수 있는 대상들을 말한다.

* 사물에는 구조 사물, 행동 사물, 그룹 사물, 주해 사물이 있다.

| 사물                         | 내용                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 구조 사물(Structural Things) | * 시스템의 개념적, 물리적 요소를 표현<br />* 클래스(Class), 유스케이스(Use Case), 컴포넌트(Component), 노드(Node) 등 |
| 행동 사물(Behavioral Things) | * 시간과 공간에 따른 요소들의 행위를 표현<br />* 상호작용(Interaction), 상태 머신(State Machine) 등 |
| 그룹 사물(Grouping Things)   | * 요소들을 그룹으로 묶어서 표현<br />* 패키지(Package)       |
| 주해 사물(Annotation Things) | * 부가적인 설명이나 제약조건 등을 표현<br />* 노트(Note)     |

### 3. 관계(Relationships)

관계는 사물과 사물 사이의 연관성을 표현하는 것으로, 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계, 실체화 관계 등이 있다.

#### 연관(Association) 관계

연관 관계는 2개 이상의 사물이 서로 관련되어 있음을 표현한다.

* 사물 사이를 실선으로 연결하여 표현하며, 방향성은 화살표로 표현한다.

* 서로에게 영향을 주는 양방향 관계의 경우 화살표를 생략하고 실선으로만 연결한다.

* 연관에 참여하는 객체의 개수를 의미하는 다중도(Multiplicity)를 선 위에 표기한다.

  | 다중도      | 의미                                     |
  | ----------- | ---------------------------------------- |
  | 1           | 1개의 객체가 연관되어 있다.              |
  | n           | n개의 객체가 연관되어 있다.              |
  | 0..1        | 연관된 객체가 없거나 1개만 존재한다.     |
  | 0..* 또는 * | 연관된 객체가 없거나 다수일 수 있다.     |
  | 1..*        | 연관된 객체가 적어도 1개 이상이다.       |
  | n..*        | 연관된 객체가 적어도 n개 이상이다.       |
  | n..m        | 연관된 객체가 최소 n개에서 최대 m개이다. |

  ex 1) 사람이 집을 소유하는 관계이다. 사람은 자기가 소유하고 있는 집에 대해 알고 있지만 집은 누구에 의해 자신이 소유되고 있는지 모른다는 의미이다.

  ![image-20240421171639536](/home/oem/engineer_information_processing/assets/image-20240421171639536.png)

  해설)

  * '사람' 쪽에 표기된 다중도가 '1'이므로 집은 한 사람에 의해서만 소유될 수 있다.
  * '집' 쪽에 표기된 다중도가 '1'이므로 사람은 집을 하나만 소유할 수 있다.

  

  ex 2) 선생님은 학생을 가르치고 학생은 선생님으로부터 가르침을 받는 것과 같이 선생님과 학생은 서로 관계가 있다.

  ![image-20240421171944884](/home/oem/engineer_information_processing/assets/image-20240421171944884.png)

  해설)

  * '선생님' 쪽에 표기된 다중도가 '1..*'이므로 학생은 한 명 이상의 선생님으로부터 가르침을 받는다.
  * '학생' 쪽에 표기된 다중도가 '1..*'이므로 선생님은 한 명 이상의 학생을 가르친다.

#### 집합(Aggregation) 관계

집합 관계는 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현한다.

* 포함하는 쪽(전체, Whole)과 포함되는 쪽(부분, Part)은 서로 독립적이다.
* 포함되는 쪽(부분, Part)에서 포함하는 쪽(전체, Whole)으로 속이 빈 마름모를 연결하여 표현한다.

ex) 프린터는 컴퓨터에 연결해서 사용할 수 있으며, 다른 컴퓨터에 연결해서 사용할 수도 있다.

![image-20240421172517980](/home/oem/engineer_information_processing/assets/image-20240421172517980.png)

#### 포함(Composition) 관계

포함 관계는 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계로 표현한다.

* 포함하는 쪽(전체, Whole)과 포함되는 쪽(부분, Part)은 서로 독립될 수 없고 생명주기를 함께한다.
* 포함되는 쪽(부분, Part)에서 포함하는 쪽(전체, Whole)으로 속이 채워진 마름모를 연결하여 표현한다.

ex) 문을 열 수 있는 키는 하나이며, 해당 키로 다른 문은 열 수 없다. 문이 없어지면 키도 더 이상 필요하지 않다.

![image-20240421172743078](/home/oem/engineer_information_processing/assets/image-20240421172743078.png)

#### 일반화(Generalization) 관계

일반화 관계는 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현한다.

* 예를 들어 사람은 여자와 남자보다 일반적인 개념이고 반대로 여자와 남자는 사람보다 구체적인 개념이다.
* 보다 일반적인 개념을 상위(부모), 보다 구체적인 개념을 하위(자식)라고 부른다.
* 구체적(하위)인 사물에서 일반적(상위)인 사물 쪽으로 속이 빈 화살표를 연결하여 표현한다.

ex) 아메리카노와 에스프레소는 커피이다. 다시 말하면, 커피에는 아메리카노와 에스프레소가 있다.

![image-20240421173141317](/home/oem/engineer_information_processing/assets/image-20240421173141317.png)

#### 의존(Dependency) 관계

의존 관계는 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현한다.

* 하나의 사물과 다른 사물이 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계이다.
* 영향을 주는 사물(이용자)이 영향을 받는 사물(제공자) 쪽으로 점선 화살표를 연결하여 표현한다.

ex) 등급이 높으면 할인율을 적용하고, 등급이 낮으면 할인율을 적용하지 않는다.

![image-20240421173415465](/home/oem/engineer_information_processing/assets/image-20240421173415465.png)

#### 실체화(Realization) 관계

실체화 관계는 사물이 할 수 있거나 해야 하는 기능(행위, 인터페이스)으로 서로를 그룹화 할 수 있는 관계를 표현한다.

* 사물에서 기능 쪽으로 속이 빈 점선 화살표를 연결하여 표현한다.

ex) 비행기는 날 수 있고 새도 날 수 있다. 그러므로 비행기와 새는 날 수 있다는 행위로 그룹화 할 수 있다.

![image-20240421174332412](/home/oem/engineer_information_processing/assets/image-20240421174332412.png)

### 4. 다이어그램(Diagram)

다이어그램은 사물과 관계를 도형으로 표현한것이다.

* 여러 관점에서 시스템을 가시화한 뷰(View)를 제공함으로써 의사소통에 도움을 준다.

* 정적 모델링에서는 주로 구조적 다이어그램을 사용하고 동적 모델리에서는 주로 행위 다이어그램을 사용한다.

* 구조적(Structural) 다이어그램의 종류

  | 다이어그램                                              | 설명                                                         |
  | ------------------------------------------------------- | ------------------------------------------------------------ |
  | 클래스 다이어그램 (Class Diagram)                       | * 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한다. <br />* 시스템의 구조를 파악하고 구조상의 문제점을 도출할 수 있다. |
  | 객체 다이어그램 (Object Diagram)                        | * 클래스에 속한 사물(객체)들, 즉 인스턴스(instance)를 특정 시점의 객체와 객체 사이의 관계로 표현한다. <br />* 럼바우(Rumbaugh) 객체지향 분석 기법에서 객체 모델링에 활용된다. |
  | 컴포넌트 다이어그램 (Component Diagram)                 | * 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현한다. <br />* 구현 단계에서 사용되는 다이어그램이다. |
  | 배치 다이어그램 (Deployment Diagram)                    | * 결과물 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현한다. <br />* 노드와 의사소통(통신) 경로로 표현한다. * 구현 단계에서 사용되는 다이어그램이다. |
  | 복합체 구조 다이어그램 (Composite Structure Diagram)    | 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현한다. |
  | 패키지 다이어그램 (Package Diagram)                     | 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현한다. |
  | 유스케이스 다이어그램 (Use Case Diagram)                | * 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용한다. <br />* 사용자(Actor)와 사용 사례(Use Case)로 구성되며, 사용 사례 간에는 여러 형태의 관계로 이루어진다. |
  | 시퀀스 다이어그램 (Sequence Diagram)                    | 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현한다. |
  | 커뮤니케이션 다이어그램 (Communication Diagram)         | 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하는데, 메시지뿐만 아니라 객체들 간의 연관까지 표현한다. |
  | 상태 다이어그램 (State Diagram)                         | * 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현한다. <br />* 럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용된다. |
  | 활동 다이어그램 (Activity Diagram)                      | 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현한다. |
  | 상호작용 개요 다이어그램 (Interaction Overview Diagram) | 상호작용 다이어그램 간의 제어 흐름을 표현한다.               |
  | 타이밍 다이어그램 (Timing Diagram)                      | 객체 상태 변화와 시간 제약을 명시적으로 표현한다.            |

※ cf) : 스테레오 타입(Stereotype)

스테레오 타입은 UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하기 위해 사용한다.

* 길러멧(Guilemet)이라고 부르는 겹화살괄효(<< >>) 사이에 표현할 형태를 기술한다.

* 주로 표현되는 형태는 다음과 같다.

  | 스테레오 타입   | 설명                                              |
  | --------------- | ------------------------------------------------- |
  | <<include>>     | 연결된 다른 UML 요소에 대해 포함 관계에 있는 경우 |
  | <<extend>>      | 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우 |
  | <<interface>>   | 인터페이스를 정의하는 경우                        |
  | <<exception>>   | 예외를 정의하는 경우                              |
  | <<constructor>> | 생성자 역할을 수행하는 경우                       |

## 10. 주요 UML 다이어그램

### 1. 유스케이스(Use Case) 다이어그램

유스케이스 다이어그램은 개발될 시스템과 관련된 외부 요소들, 즉 사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점(View)에서 표현한 것이다.

* 외부 요소와 시스템 간의 상호 작용을 확인할 수 있다.
* 사용자의 요구사항을 분석하기 위한 도구로 사용된다.
* 시스템의 범위를 파악할 수 있다.

#### 유스케이스 다이어그램의 구성 요소

유스케이스 다이어그램은 시스템 범위, 액터, 유스케이스, 관계로 구성된다.

| 구성 요소                                  | 설명                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| 시스템(System) / 시스템 범위(System Scope) | 시스템 내부에서 수행되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현함 |
| 액터(Actor)                                | * 시스템과 상호작용을 하는 모든 외부요소로, 사람이나 외부 시스템을 의미함<br />* 주액터 : 시스템을 사용함으로써 이득을 얻는 대상으로, 주로 사람이 해당함<br />* 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로, 조직이나 기관 등이 될 수 있음 |
| 유스케이스(Use Case)                       | 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현한 것 |
| 관계(Relationship)                         | 유스케이스 다이어그램에서 관계는 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있으며, 포함 관계, 확장 관계, 일반화 관계의 3종류가 있음 |

### 2. 클래스(Class) 다이어그램

클래스 다이어그램은 시스템을 구성하는 클래스, 클래스의 특성인 속성과 오퍼레이션, 속성과 오퍼레이션에 대한 제약조건, 클래스 사이의 관계를 표현한 것이다.

* 클래스 다이어그램은 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램이다.
* 클래스 다이어그램은 시스템 구성 요소를 문서화하는 데 사용된다.
* 코딩에 필요한 객체의 속성, 함수 등의 정보를 잘 표현하고 있어 시스템을 모델링하는 데 자주 사용된다.

#### 클래스 다이어그램의 구성 요소

클래스 다이어그램은 클래스, 제약조건, 관계 등으로 구성된다.

| 구성 요소           | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| 클래스(Class)       | * 클래스는 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현함<br />* 일반적으로 3개의 구획(Compartment)으로 나눠 클래스의 이름, 속성, 오퍼레이션을 표기함<br />* 속성(Attribute) : 클래스의 상태나 정보를 표현함<br />* 오퍼레이션(Operation) : 클래스가 수행할 수 있는 동작으로, 함수(메소드, Method)라고도 함 |
| 제약조건            | 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 적음 |
| 관계(Relationships) | * 관계는 클래스와 클래스 사이의 연관성을 표현함<br />* 클래스 다이어그램에 표현하는 관계에는 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계가 있음 |

※ cf) : 접근제어자

접근제어자는 속성과 오퍼레이션에 동일하게 적용되며, 표현법은 다음과 같다.

| 접근제어자 | 표현법 | 내용                                                         |
| ---------- | ------ | ------------------------------------------------------------ |
| public     | +      | 어떤 클래스에서라도 접근 가능                                |
| private    | -      | 해당 클래스 내부에서만 접근 가능                             |
| protected  | #      | 동일 패키지 내의 클래스 또는 해당 클래스를 상속 받는 외부 패키지의 클래스에서 접근 가능 |
| package    | ~      | 동일 패키지 내부에 있는 클래스에서만 접근 가능               |

### 3. 시퀀스(Sequence) 다이어그램

시퀀스 다이어그램은 시스템이나 객체들이 메시지를 주고받으며 시간의 흐름에 따라 상호 작용하는 과정을 액터, 객체, 메시지 등의 요소를 사용하여 그림으로 표현한 것이다.

* 시퀀스 다이어그램은 시스템이나 객체들의 상호 작용 과정에서 주고받는 메시지를 표현한다.
* 시퀀스 다이어그램을 통해 각 동작에 참여하는 시스템이나 객체들의 수행 기간을 확인할 수 있다.
* 시퀀스 다이어그램은 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호 작용을 표현한다.
* 시퀀스 다이어그램은 주로 기능 모델링에서 작성한 유스케이스 명세서를 하나의 표현 범위로 하지만, 하나의 클래스에 포함된 오퍼레이션을 하나의 범위로 표현하기도 한다.

#### 시퀀스 다이어그램의 구성 요소

시퀀스 다이어그램은 액터, 객체, 생명선, 실행, 메시지 등으로 구성된다.

| 구성 요소             | 내용                                                         |
| --------------------- | ------------------------------------------------------------ |
| 액터(Actor)           | 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미함 |
| 객체(Object)          | 메시지를 주고받는 주체                                       |
| 생명선(Lifeline)      | 객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 점선을 그어 표현함 |
| 실행 상자(Active Box) | 객체가 메시지를 주고받으며 구동되고 있음을 표현함            |
| 메시지(Message)       | 객체가 상호 작용을 위해 주고받는 메시지                      |

# 2장. 화면 설계

## 11. 사용자 인터페이스

### 1. 사용자 인터페이스(UI, User Interface)의 개요

사용자 인터페이스(UI)는 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어를 의미한다.

* 초기의 사용자 인터페이스는 단순히 사용자와 컴퓨터 간의 상호작용에만 국한되었지만 점차 사용자가 수행할 작업을 구체화시키는 기능 위주로 변경되었고, 최근에는 정보 내용을 전달하기 위한 표현 방법으로 변경되었다.
* 사용자 인터페이스의 세 가지 분야
  * 정보 제공과 전달을 위한 물리적 제어에 관한 분야
  * 콘텐츠의 상세적인 표현과 전체적인 구성에 관한 분야
  * 모든 사용자가 편리하고 간편하게 사용하도록 하는 기능에 관한 분야

### 2. 사용자 인터페이스(UI)의 특징

* 사용자의 만족도에 가장 큰 영향을 미치는 중요한 요소로, 소프트웨어 영역 중 변경이 가장 많이 발생한다.
* 사용자의 편리성과 가독성을 높임으로써 작업 시간을 단축시키고 업무에 대한 이해도를 높여준다.
* 최소한의 노력으로 원하는 결과를 얻을 수 있게 한다.
* 수행 결과의 오류를 줄인다.
* 사용자의 막연한 작업 기능에 대해 구체적인 방법을 제시해 준다.
* 정보 제공자와 공급자 간의 매개 역할을 수행한다.
* 사용자 인터페이스를 설계하기 위해서는 소프트웨어 아키텍처를 반드시 숙지해야 한다.

※ cf) : 소프트웨어 아키텍처

건물을 짓기 위해 설계도를 작성하듯 소프트웨어 아키텍처는 개발할 소프트웨어의 기본 틀을 만드는 것으로, 복잡한 소프트웨어 개발 과정을 체계적으로 접근하기 위한 밑그림이다.

* 소프트웨어 아키텍처는 개발하고자 하는 소프트웨어의 특성과 본질을 파악하고 다양한 시각에서 모형화 한다.
* 소프트웨어 아키텍처는 전체 시스템의 전반적인 구조를 설계한다.
* 소프트웨어 아키텍처는 소프트웨어 시스템의 구축 및 개선을 용이하도록 한다.
* 소프트웨어 아키텍처는 작업자들 간의 상호 이해, 타협 및 의사소통을 원활하게 하기 위해 사용된다.

### 3. 사용자 인터페이스의 구분

사용자 인터페이스는 상호작용의 수단 및 방식에 따라 다음과 같이 구분된다.

* CLI(Command Line Interface)

  명령과 출력이 텍스트 형태로 이뤄지는 인터페이스

* GUI(Graphical User Interface)

  아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스

* NUI(Natural User Interface)

  사용자의 말이나 행동으로 기기를 조작하는 인터페이스

### 4. 사용자 인터페이스의 기본 원칙

사용자 인터페이스의 기본 원칙에는 직관성, 유효성, 학습성, 유연성이 있다.

* 직관성

  누구나 쉽게 이해하고 사용할 수 있어야 한다.

* 유효성

  사용자의 목적을 정확하고 완벽하게 달성해야 한다.

* 학습성

  누구나 쉽게 배우고 익힐 수 있어야 한다.

* 유연성

  사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다.

### 5. 사용자 인터페이스의 설계 지침

사용자 인터페이스를 설계할 때 고려할 사항은 사용자 중심, 일관성, 단순성, 결과 예측 가능, 가시성, 접근성, 명확성, 오류 발생 해결 등이다.

* 사용자 중심

  사용자가 쉽게 이해하고 편리하게 사용할 수 있는 환경을 제공하며, 실사용자에게 대한 이해가 바탕이 되어야 한다.

* 일관성

  버튼이나 조작 방법 등을 일관성 있게 제공하므로 사용자가 쉽게 기억하고 습득할 수 있게 설계해야 한다.

* 단순성

  조작 방법을 단순화시켜 인지적 부담을 감소시켜야 한다.

* 결과 예측 기능

  작동시킬 기능만 보고도 결과를 미리 예측할 수 있게 설계해야 한다.

* 가시성

  메인 화면에 주요 기능을 노출시켜 최대한 조작이 쉽도록 설계해야 한다.

* 표준화

  기능 구조와 디자인을 표준화하여 한 번 학습한 이후에는 쉽게 사용할 수 있도록 설계해야 한다.

* 접근성

  사용자의 연령, 성별, 인종 등 다양한 계층이 사용할 수 있도록 설계해야 한다.

* 명확성

  사용자가 개념적으로 쉽게 인지할 수 있도록 설계해야 한다.

* 오류 발생 해결

  오류가 발생하면 사용자가 쉽게 인지할 수 있도록 설계해야 한다.

### 6. 사용자 인터페이스 개발 시스템의 기능

사용자 인터페이스 개발 시스템이 가져야 할 기능은 다음과 같다.

* 사용자의 입력을 검증할 수 있어야 한다.
* 에러 처리와 그와 관련된 에러 메시지를 표시할 수 있어야 한다.
* 도움과 프롬프트(Prompt)를 제공해야 한다.

## 12. UI 표준 및 지침

### 1. UI 표준 및 지침

UI 표준과 지침을 토대로 기술의 중립성(웹 표준), 보편적 표현 보장성(웹 접근성), 기능의 호환성(웹 호환성)이 고려되었는지 확인한다.

* UI 표준

  전체 시스템에 포함된 모든 UI에 공통적으로 적용될 내용으로, 화면 구성이나 화면 이동 등이 포함된다.

* UI 지침

  UI 요구사항, 구현 시 제약사항 등 UI 개발 과정에서 꼭 지켜야 할 공통의 조건을 의미한다.

※ cf) : 웹의 3요소

웹의 3요소는 웹 사이트 개발 시 고려할 사항으로 웹 표준, 웹 접근성, 웹 호환성을 말한다.

* 웹 표준(Web Standards)

  웹에서 사용되는 규칙 또는 기술을 의미하는 것으로, 웹 사이트 작성 시 이용하는 HTML, JS 등에 대한 규정, 웹 페이지가 다른 기종이나 플랫폼에서도 구현되도록 제작하는 기법 등을 포함한다.

* 웹 접근성(Web Accessibility)

  누구나, 어떠한 환경에서도 웹 사이트에서 제공하는 모든 정보를 접근하여 이용할 수 있도록 보장하는 것을 의미한다.

* 웹 호환성(Cross Browsing)

  하드웨어나 소프트웨어 등이 다른 환경에서도 모든 이용자에게 동등한 서비스를 제공하는 것을 의미한다.

### 2. 한국형 웹 콘텐츠 접근성 지침(KWCAG; Korean Web Content Accessibility Guidelines)

'한국형 웹 콘텐츠 접근성 지침'은 장애인이 비장애인과 동등하게 접근할 수 있는 웹 콘텐츠의 제작 방법을 제시한다.

* '한국형 웹 콘텐츠 접근성 지침'의 목적은 웹 콘텐츠 저작자, 웹 사이트 설계자 등이 접근성이 보장된 웹 콘텐츠를 쉽게 제작할 수 있도록 도와주는 것이다.

* '한국형 웹 콘텐츠 접근성 지침'에는 웹 접근성의 준수 여부를 평가할 수 있는 요구 조건과 이를 모두 준수할 경우 얻을 수 있는 기대 효과가 제시되어 있다.

* 웹 콘텐츠 접근성(사용성) 지침 준수를 위한 고려 사항

  ![image-20240424014050589](/home/oem/engineer_information_processing/assets/image-20240424014050589.png)

※ cf) : 내비게이션(Navigation)

내비게이션은 사용자가 사이트에서 원하는 정보를 빠르게 찾을 수 있도록 안내하는 것으로 사용자가 중심이 되어야 한다.

* 내비게이션은 원하는 정보를 쉽고 빠르게 찾을 수 있도록 다양한 경로나 방법을 제공해야 한다.

* 내비게이션은 메뉴, 사이트 맵, 버튼, 링크 등으로 구성되는데, 이들 구성 요소는 사용자가 직관적으로 찾아 사용할 수 있도록 설계되어야 하고, 사용자가 혼동하지 않도록 전체 페이지에서 일관성이 있어야 한다.

* 내비게이션 구조의 요소

  * 메뉴(단추)

    계층 구조를 표현하는 기본 요소로, 사용자가 원하는 페이지로 이동할 수 있게 한다.

  * 링크

    원하는 페이지로 이동할 수 있게 하는 하이퍼링크를 의미한다.

  * 이미지맵

    그림에 하이퍼링크를 연결하여 원하는 페이지로 이동할 수 있게 한다.

  * 사이트 맵

    사이트의 전체 구조를 한 눈에 알아볼 수 있도록 트래 구조 형태로 만든 것이다.

  * 사이트 메뉴바

    사이트의 좌측이나 우측에 메뉴, 링크 등을 모아둔 것이다.

  * 내비게이션 바

    메뉴를 한 곳에 모아 놓은 그래픽이나 문자열 모음이다.

  * 디렉터리

    주제나 항목을 카테고리별로 표현한 방식이다.

### 전자정부 웹 표준 준수 지침

'전자정부 웹 표준 준수 지침'은 정부기관의 홈페이지 구축 시 반영해야 할 최소한의 규약을 정의한 것으로, 모든 사람이 시스템 환경에 구애받지 않고 정부기관의 홈페이지를 이용할 수 있도록 하기 위한 것이다.

* '전자정부 웹 표준 준수 지침'에는 이를 준수할 경우의 기대 효과가 제시되어 있다.

* 전자정부 웹 표준 준수 지침 사항

  | 지침 사항                       | 내용                                                         |
  | ------------------------------- | ------------------------------------------------------------ |
  | 내용의 문법 준수                | * 모든 웹 문서는 적절한 문서타입을 명시해야 한다.<br />* 명시한 문서타입에 맞는 문법을 준수해야 한다.<br />* 모든 페이지는 사용할 인코딩 방식을 표기해야 한다. |
  | 내용의 표현의 분리              | * 논리적인 마크업 언어를 사용하여 웹 문서를 구조화해야 한다.<br />* 사용된 스타일 언어는 표준적인 문법을 준수해야 한다. |
  | 동작의 기술 중립성 보장         | * 스크립트의 비표준 문법을 확장하는 것은 배제해야 한다.<br />* 스크립트 비사용자를 위해 대체 텍스트나 정보를 제공해야 한다. |
  | 플러그인의 호환성               | 플러그인은 다양한 웹 브라우저에서 호환되는 것을 사용해야 한다. |
  | 콘텐츠의 보편적 표현            | * 메뉴는 다양한 브라우저에서 접근할 수 있어야 한다.<br />* 웹 사이트를 다양한 인터페이스로 이용할 수 있어야 한다. |
  | 운영체제에 독립적인 콘텐츠 제공 | 제공되는 미디어는 운영체제에 종속적이지 않은 범용적인 포맷을 사용해야 한다. |
  | 부가 기능의 호환성 확보         | 실명인증, 전자인증 등의 부가 기능은 다양한 브라우저에서 사용할 수 있어야 한다. |
  | 다양한 프로그램 제공            | * 정보를 열람하는 기능은 다양한 브라우저에서 사용할 수 있어야 한다.<br />* 별도의 다운로드가 필요한 프로그램은 윈도우, 리눅스, 메킨토시 중 2개 이상의 운영체제를 지원해야 한다. |

## 13. UI 설계 도구

### 1. UI 설계 도구

UI 설계 도구는 사용자의 요구사항에 맞게 UI의 화면 구조나 화면 배치 등을 설계할 때 사용하는 도구로, 종류에는 와이어프레임, 목업, 스토리보드, 프로토타입, 유스케이스 등이 있다.

* UI 설계 도구로 작성된 결과물은 사용자의 요구사항이 실제 구현되었을 때 화면은 어떻게 구성되는지, 어떤 방식으로 수행되는지 등을 기획단계에서 미리 보여주기 위한 용도로 사용된다.

### 2. 와이어 프레임(Wireframe)

와이어프레임은 기획 단계의 초기에 제작하는 것으로, 페이지에 대한 개략적인 레이아웃이나 UI 요소 등에 대한 뼈대를 설계하는 단계이다.

* 와이어프레임을 제작할 때는 각 페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계한다.

* 개발자나 디자이너 등이 레이아웃을 협의하거나 현재 진행 상태 등을 공유하기 위해 와이어프레임을 사용한다.

* 와이어프레임 툴

  손그림, 파워포인트, 키노트, 스케치, 일러스트, 포토샵 등

### 3. 목업(Mockup)

목업은 디자인, 사용 방법 설명, 평가 등을 위해 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형이다.

* 시각적으로만 구성 요소를 배치하는 것으로 실제로 구현되지는 않는다.

* 목업 툴

  파워 목업, 발사믹 목업 등

### 4. 스토리보드(Story Board)

스토리보드는 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서이다.

* 디자이너와 개발자가 최종적으로 참고하는 작업 지침서로, 정책, 프로세스, 콘텐츠 구성, 와이어프레임, 기능 정의 등 서비스 구축을 위한 모든 정보가 들어 있다.

* 스토리보드는 상단이나 우측에는 제목, 작성자 등을 입력하고, 좌측에는 UI 화면, 우측에는 디스크립션(Description)을 기입한다.

* 디스크립션(Description)은 화면에 대한 설명, 전반적인 로직, 분기처리, 예외처리 등을 작성하는 부분으로, 명확하고 세부적으로 작성해야 한다.

* 스토리보드 툴

  파워포인트, 키노트, 스케치, Axure 등

### 5. 프로토타입(Prototype)

프로토타입은 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형이다.

* 프로토타입은 사용성 테스트나 작업자 간 서비스 이해를 위해 작성하는 샘플이다.

* 프로토타입은 작성 방법에 따라 페이퍼 프로토타입과 디지털 프로토타입으로 나뉜다.

* 프로토타입 툴

  HTML / CSS, Axure, Flinto, 네이버 프로토나우, 카카오 오븐 등

### 6. 유스케이스(Use Case)

유스케이스는 사용자 측면에서의 요구사항으로, 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다.

* 사용자의 요구사항을 빠르게 파악함으로써 프로젝트의 초기에 시스템의 기능적인 요구를 결정하고 그 결과를 문서화할 수 있다.
* 유스케이스는 자연어로 작성된 사용자의 요구사항을 구조적으로 표현한 것으로, 일반적으로 다이어그램 형식으로 묘사된다.
* 유스케이스 다이어그램이 완성되면, 각각의 유스케이스에 대해 유스케이스 명세서를 작성한다.

## 14. UI 요구사항 확인

### 1. UI 요구사항 확인

UI 요구사항 확인은 새로 개발할 시스템에 적용할 UI 관련 요구사항을 조사해서 작성하는 단계로, 다양한 경로를 통해 사용자의 요구사항을 조사하고 분석한 후 작성해야 한다.

* UI 요구사항 확인 순서는 다음과 같다.

  `목표 정의` → `활동 사항 정의` → `UI 요구사항 작성`

### 2. 목표 정의

목표 정의 단계에서는 사용자들을 대상으로 인터뷰를 진행한 후 사용자들의 의견이 수렴된 비즈니스 요구사항을 정의한다.

* 인터뷰를 통해 사업적, 기술적인 요구사항을 명확히 이해한다.
* 인터뷰 진행 시 유의사항
  * 인터뷰는 가능하면 개별적으로 진행한다.
  * 가능한 많은 사람을 인터뷰하여 다양한 의견을 수렴하되, 다수의 의견으로 인해 개인의 중요한 의견을 놓치지 않도록 주의한다.
  * 인터뷰는 한 시간을 넘지 않도록 한다.
  * 인터뷰 진행은 반드시 사용자 리서치를 시작하기 전에 해야 한다.

### 3. 활동 사항 정의

활동 사항 정의 단계에서는 조사한 요구사항을 토대로 앞으로 해야 할 활동 사항을 정의한다.

* 사용자와 회사의 비전을 일치시키는 작업을 진행한다.
* 리서치 규모, 디자인 목표 등을 결정할 수 있도록 각각에 필요한 예산과 일정을 결정한다.
* 기술의 발전 가능성을 파악하고 UI 디자인의 방향을 제사힌다.
* 인터뷰한 내용을 기반으로 경영진마다 다르게 이해하고 있는 프로젝트에 대해 정확히 이해하고 협의하도록 돕는다.
* 사업 전략 및 목표, 프로세스의 책임자 선정, 회의 일정 및 계획 작성, 우선순위의 선정, 개별적인 단위 업무를 구분한다.

### 4. UI 요구사항 작성

UI 요구사항을 작성할 때는 여러 경로를 통해 수집된 사용자들의 요구사항을 검토하고 분석하여 UI 개발 목적에 맞게 작성해야 한다.

* UI 요구사항은 반드시 실사용자 중심으로 작성되어야 한다.

* UI 요구사항은 여러 사람의 인터뷰를 통해 다양한 의견을 수렴해서 작성해야 한다.

* UI 요구사항을 바탕으로 UI의 전체적인 구조를 파악 및 검토해야 한다.

* UI 요구사항 작성 순서는 다음과 같다.

  `요구사항 요소 확인` → `정황 시나리오 작성` → `요구사항 작성`

### 5. 요구사항 요소 확인

파악된 요구사항 요소의 종류와 각각의 표현 방식 등을 검토한다.

* 요구사항 요소

  | 요구사항 요소        | 내용                                                         |
  | -------------------- | ------------------------------------------------------------ |
  | 데이터 요구          | * 사용자가 요구하는 모델과 객체들의 주요 특성을 기반으로 하여 데이터 객체들을 정리한다.<br />* 인터페이스 구성에 영향을 미치므로 반드시 초기에 확인해야 한다.<br />ex) 이메일의 메시지 속성은 제목, 발신인, 참조인, 답변 등이다. |
  | 기능 요구            | * 사용자의 목적 달성을 위해 무엇을 실행해야 하는지를 동사형으로 설명한다.<br />* 기능 요구 리스트는 최대한 철저하게 정리해야 한다.<br />ex) 사용자는 이메일의 메시지를 읽거나 삭제하며, 일정한 양식으로 다른 메시지와 함께 보관한다. |
  | 제품 / 서비스의 품질 | 데이터 및 기능 요구 외에 제품의 품질, 서비스, 여기에 감성적인 품질 등을 고려하여 작성한다.<br />ex) 시스템이 파일을 얼마나 빠르게 처리할 수 있는지 여부 등 정량화가 가능한 요구사항들을 확인한다. |
  | 제약 사항            | * 제품 완료 데드라인, 전체 개발 및 제작에 필요한 비용, 시스템 준수에 필요한 규제가 포함된다.<br />* 사전에 제약사항의 변경 가능 여부를 확인한다. |

### 6. 정황 시나리오 작성

정황 시나리오는 사용자의 요구사항을 도출하기 위해 작성하는 것으로, 사용자가 목표를 달성하기 위해 수행하는 방법을 순차적으로 묘사한 것이다.

* 정황 시나리오는 요구사항 정의에 사용되는 초기 시나리오이다.
* 정황 시나리오는 개발하는 서비스의 모습을 상상하는 첫 번째 단계로 사용자 관점에서 시나리오를 작성해야 한다.
* 사용자가 주로 사용하는 기능 위주로 작성해야 하며, 함께 발생되는 기능들은 하나의 시나리오에 통합한다.
* 육하원칙에 따라 간결하고 명확하게 작성한다.
* 작성된 시나리오는 외부 전문가 또는 경험이 풍부한 사람에게 검토를 의뢰한다.

### 7. 요구사항 작성

요구사항은 정황 시나리오를 토대로 작성한다.

ex) 요구사항 작성

| 정황 시나리오                                                | 요구사항                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 윤희는 회의가 끝난 후 핸드폰을 켰다. 주요 회의 내용을 메모하고 다음 약속을 확인하는 한편, 회의 동안 중요한 전화가 있었는지 확인했다. | * 문자를 입력할 수 있어햐 한다.<br />* 약속을 추적할 수 있어야 한다.<br />* 메시지 리스트를 확인할 수 있어야 한다.<br />* 핸드폰으로 구현이 가능해야 한다. |

## 15. 품질 요구사항

### 1. 품질 요구사항

소프트웨어의 품질은 소프트웨어의 기능, 성능, 만족도 등 소프트웨어에 대한 요구사항이 얼마나 충족하는가를 나타내는 소프트웨어 특성의 총체이다.

* 소프트웨어의 품질은 사용자의 요구사항을 충족시킴으로써 확립된다.

* ISO/IEC 9126

  * ISO/IEC 9126은 소프트웨어의 품질 특성과 평가를 위한 표준 지침으로서 국제 표준으로 널리 사용된다.
  * ISO/IEC 9126은 소프트웨어의 품질에 대한 요구사항을 기술하거나 개발중인 또는 개발이 완료된 소프트웨어의 품질 평가 등에 사용된다.
  * ISO/IEC 9126은 2011년에 호환성과 보안성을 강화하여 ISO/IEC 25010으로 개정되었다.
  * ISO/IEC 9126에서 제시한 소프트웨어의 품질 특성

  ![img](https://blog.kakaocdn.net/dn/ewxSRL/btqJF0oLXbK/gPivsc5E0sWCDnffTNsEn1/img.jpg)

  * ISO/IEC 25010
    * ISO/IEC 25010은 소프트웨어 제품에 대한 국제 표준으로, 2011년에 ISO/IEC 9126을 개정하여 만들었다.
    * ISO/IEC 25010에서 제시한 소프트웨어의 품질 특성

![img](https://blog.kakaocdn.net/dn/cekdXp/btqJINP0nCP/K8vJVWmpjkgvIgPeoFG1n1/img.jpg)

※ cf) : 기타 소프트웨어 품질 관련 표준

* ISO/IEC 12119

  ISO/IEC 9126을 준수한 품질 표준으로, 테스트 절차를 포함하여 규정함

* ISO/IEC 14598

  소프트웨어 품질의 측정과 평가에 필요 절차를 규정한 표준으로, 개발자, 구매자, 평가자 별로 수행해야 할 제품 평가 활동을 규정함

### 2. 기능성(Functionality)

기능성은 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부를 나타낸다.

| 상세 품질 요구사항            | 설명                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| 적절성/적합성(Suitability)    | 지정된 작업과 사용자의 목적 달성을 위해 적절한 기능을 제공할 수 있는 능력 |
| 정밀성/정확성(Accuracy)       | 사용자가 요구하는 결과를 정확하게 산출할 수 있는 능력        |
| 상호 운용성(Interoperability) | 다른 시스템들과 서로 어울려 작업할 수 있는 능력              |
| 보안성(Security)              | 정보에 대한 접근을 권한에 따라 허용하거나 차단할 수 있는 능력 |
| 준수성(Compliance)            | 기능과 관련된 표준, 관례 및 규정을 준수할 수 있는 능력       |

### 3. 신뢰성(Reliability)

신뢰성은 소프트웨어가 요구된 기능을 정확하고 일관되게 오류 없이 수행할 수 있는 정도를 나타낸다.

| 상세 품질 요구사항            | 설명                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| 성숙성(Maturity)              | 결함으로 인한 고장을 피해갈 수 있는 능력                     |
| 고장 허용성(Faulty Tolerance) | 결함 또는 인터페이스 결여 시에도 규정된 성능 수준을 유지할 수 있는 능력 |
| 회복성(Recoverability)        | 고장 시 규정된 성능 수준까지 다시 회복하고 직접적으로 영향 받은 데이터를 복구할 수 있는 능력 |

### 4. 사용성(Usability)

사용성은 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대하여 사용자가 정확하게 이해하고 사용하며, 향후 다시 사용하고 싶은 정도를 나타낸다.

| 상세 품질 요구사항        | 설명                                                         |
| ------------------------- | ------------------------------------------------------------ |
| 이해성(Understandability) | 소프트웨어의 적합성, 사용 방법 등을 사용자가 이해할 수 있는 능력 |
| 학습성(Learnability)      | 소프트웨어 어플리케이션을 학습할 수 있도록 하는 능력         |
| 운용성(Operability)       | 사용자가 소프트웨어를 운용하고 제어할 수 있도록 하는 능력    |
| 친밀성(Attractiveness)    | 사용자가 소프트웨어를 다시 사용하고 싶어 하도록 하는 능력    |

### 5. 효율성(Efficiency)

효율성은 사용자가 요구하는 기능을 할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도를 나타낸다.

| 상세 품질 요구사항              | 설명                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| 시간 효율성(Time Behaviour)     | 특정 기능을 수행할 때 적절한 반응 시간 및 처리 시간, 처리율을 제공할 수 있는 능력 |
| 자원 효율성(Resource Behaviour) | 특정 기능을 수행할 때 적절한 자원의 양과 종류를 제공할 수 있는 능력 |

### 6. 유지 보수성(Maintainability)

유지 보수성은 환경의 변화 또는 새로운 요구사항이 발생했을 때 소프트웨어를 개선하거나 확장할 수 있는 정도를 나타낸다.

| 상세 품질 요구사항    | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| 분석성(Analyzability) | 결함이나 고장의 원인, 수정될 부분들의 식별을 가능하게 하는 능력 |
| 변경성(Changeability) | 결함 제거 또는 환경 변화로 인한 수정 등을 쉽게 구현할 수 있는 능력 |
| 안정성(Stability)     | 변경으로 인한 예상치 못한 결과를 최소화할 수 있는 능력       |
| 시험성(Testability)   | 소프트웨어의 변경이 검증될 수 있는 능력                      |

### 7. 이식성(Portability)

이식성은 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도를 나타낸다.

| 상세 품질 요구사항     | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 적용성(Adaptability)   | 원래의 목적으로 제공되는 것 외에 다른 환경으로 변경될 수 있는 능력 |
| 설치성(Installability) | 임의의 환경에 소프트웨어를 설치할 수 있는 능력               |
| 대체성(Replaceability) | 동일한 환경에서 동일한 목적을 위해 다른 소프트웨어를 대신하여 사용될 수 있는 능력 |
| 공존성(Co-existence)   | 자원을 공유하는 환경에서 다른 소프트웨어와 공존할 수 있는 능력 |

## 16. UI 프로토타입 제작 및 검토

### 1. UI 프로토타입의 개요

프로토타입은 사용자 요구사항을 기반으로 실제 동작하는 것처럼 만든 동적인 형태의 모형으로, 테스트가 가능하다.

* 프로토타입은 사용자의 요구사항을 개발자가 맞게 해석했는지 검증하기 위한 것으로, 최대한 간단하게 만들어야 한다.
* 프로토타입은 일부 핵심적인 기능만을 제공하지만 최종 제품의 작동 방식을 이해시키는데 필요한 기능은 반드시 포함되어야 한다.
* 사용자의 요구사항이 모두 반영될 때까지 프로토타입을 계속하여 개선하고 보완해야 한다.
* 프로토타이핑 및 테스트를 거치지 않고는 실제 사용자와 제품 간의 상호 작용 방식을 예측하기 어려우므로 실제 사용자를 대상으로 테스트하는 것이 좋다.

### 2. UI 프로토타입의 장·단점

| 장·단점 | 내용                                                         |
| ------- | ------------------------------------------------------------ |
| 장점    | * 사용자를 설득하고 이해시키기 쉽다.<br />* 요구사항과 기능의 불일치 등으로 인한 혼선을 예방할 수 있어 개발 시간을 줄일 수 있다.<br />* 사전에 오류를 발견할 수 있다. |
| 단점    | * 프로토타입에 사용자의 모든 요구사항을 반영하기 위한 반복적인 개선 및 보완 작업 때문에 작업 시간을 증가 시킬 수 있고, 필요 이상으로 자원을 소모할 수 있다.<br />* 부분적으로 프로토타이핑을 진행하다보면 중요한 작업이 생략될 수 있다. |

### 3. 프로토타이핑의 종류

| 프로토타이핑 종류                    | 내용                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 페이퍼 프로토타입(Paper Prototype)   | * 아날로그적인 방법으로, 스케치, 그림, 글 등을 이용하여 손으로 직접 작성하는 방법이다.<br />* 제작 기간이 짧은 경우, 제작 비용이 적을 경우, 업무 협의가 빠를 경우 사용한다.<br />* 장점<br />- 비용이 저렴하다<br />- 회의 중 대화하면서 생성이 가능하다.<br />- 즉시 변경이 가능하다.<br />- 고객이 과다한 기대를 하지 않는다.<br />* 단점<br />- 테스트하기에 부적당하다.<br />- 상호 관계가 많은 경우 나타내기 복잡하다.<br />- 여러 사람들에게 나눠주거나 공유하기 어렵다. |
| 디지털 프로토타입(Digital Prototype) | * 파워포인트, 아크로뱃, 비지오, 옴니그래플 등과 같은 프로그램을 사용하여 작성하는 방법이다.<br />* 재사용이 필요한 경우, 산출물과 비슷한 효과가 필요한 경우, 숙련된 전문가가 있을 경우 사용한다.<br />* 장점<br />- 최종 제품과 비슷하게 테스트할 수 있다.<br />- 수정하기 쉽다.<br />- 재사용이 가능하다.<br />* 단점<br />- 프로토타입을 작성할 프로그램의 사용법을 알아야 한다. |

### 4. UI 프로토타입 계획 및 작성 시 고려 사항

프로토타입은 일반적으로 프로토타입의 개발 계획을 수립하는 과정과 프로토타입을 개발한 후 결과를 보고하는 과정으로 진행된다.

| 고려사항          | 내용                                                         |
| ----------------- | ------------------------------------------------------------ |
| 계획 시 고려 사항 | * 프로토타입의 개발 목적을 확인한다.<br />* 소프트웨어, 하드웨어 등 프로토타입 개발에 필요한 환경을 마련한다.<br />* 프로토타이핑 일정은 일반적으로 아키텍처가 확정된 이후 프로젝트의 실제 분석 작업이 완료되기 이전에 진행해야 한다.<br />* 아키텍처의 핵심이 되는 UI 요소를 프로토타입의 범위로 잡는다.<br />* 리더, 솔루션 담당자, 인프라 담당자, 개발 환경 리더, 공통 모듈 개발자, 프로토타입 개발자 등 프로토타입의 개발 인원을 확인한다.<br />* 주어진 비즈니스 요구사항을 모두 만족하는지 프로토타입 아키텍처를 검증한다.<br />* 프로토타입을 통해서 발생하는 이슈를 모두 취합하고 해결 방법을 제시한다.<br />* 프로토타이핑을 진행하면서 분석 설계, 개발, 테스트 등의 표준 가이드를 확정한다.<br />* 프로토타이핑을 진행하면서 가장 많은 시간이 소요된 구간을 찾고 그 원인을 분석하여 해결 방법을 제시한다.<br />* 고객과 프로젝트 매니저, 프로젝트 리더 등에게 완성된 프로토타입을 시연한다. |
| 작성 시 고려 사항 | * 프로토타입의 작성 계획을 세운다.<br />* 프로젝트의 범위나 리스크 상황 등 주변 여건을 감안해서 프로토타입의 범위를 정한다.<br />* 프로토타입을 통해서 얻고자 하는 목표를 확인한다.<br />* 프로토타입의 개발 목표를 달성하기 위해 필요한 최소한의 기간과 비용을 확인한다.<br />* 완성된 프로토타입이 실제 개발에 참조될 수 있는지 확인한다.<br />* 프로토타입으로 검증할 범위가 너무 넓거나 기간이 길면 목표가 커져서 문제가 될수 있으니 주의한다. |

### 5. UI 프로토타입 제작 단계

| 단계  | 내용                                                         |
| ----- | ------------------------------------------------------------ |
| 1단계 | 사용자의 요구사항을 분석하는 단계로, 사용자 관점에서 기본적인 요구사항이 확정될 때까지 수행한다. |
| 2단계 | * 요구사항을 충족하는 프로토타입을 종이에 손으로 직접 그리거나 편집 도구 등을 이용하여 작성한다.<br />* 프로토타입은 개발할 시스템의 핵심적인 기능을 중심으로 개발한다. |
| 3단계 | * 작성된 프로토타입이 요구사항을 잘 수행하고 있는지 사용자가 직접 확인하는 단계이다.<br />* 프로토타입에 대해 다양한 추가 및 수정 의견을 제안할 수 있다. |
| 4단계 | * 작성된 프로토타입을 기반으로 수정과 합의가 이뤄지는 단계이다.<br />* 개발자는 사용자가 요청한 제안 사항을 수용하여 보완 작업을 한다.<br />* 작업이 완료된 후 3단계로 되돌아간다.<br />* 사용자가 최종적으로 승인을 완료할 때까지 3단계와 4단계가 반복된다. |

## 17. UI 설계서 작성

### 1. UI 설계서의 개요

UI 설계서는 사용자의 요구사항을 바탕으로 UI 설계를 구체화하여 작성하는 문서로, 상세 설계 전에 대표적인 화면들을 설계한다.

* UI 설계서는 기획자, 개발자, 디자이너 등과의 원활한 의사소통을 위해 작성한다.
* UI 설계서는 UI 설계서 표지, UI 설계서 개정 이력, UI 요구사항 정의서, 시스템 구조, 사이트 맵, 프로세스 정의서, 화면 설계 순으로 작성한다.

### 2. UI 설계서 표지 작성

UI 설계서 표지는 다른 문서와 혼동되지 않도록 프로젝트명 또는 시스템명을 포함시켜 작성한다.

ex) UI 설계서 : 표지

<img src="/home/oem/engineer_information_processing/assets/image-20240424034748624.png" alt="image-20240424034748624" style="zoom:80%;" />

### 3. UI 설계서 개정 이력 작성

UI 설계서 개정 이력은 UI 설계서가 수정될 때마다 어떤 부분이 어떻게 수정되었는지를 정리해 놓은 문서이다.

* 처음 작성 시 첫 번째 항목을 '초안 작성', 버전(Version)을 1.0으로 설정한다.

* UI 설계서에 변경 사항이 있을 때마다 변경 내용을 적고 버전을 0.1씩 높인다.

  ex) UI 설계서 : 개정 이력

  | No   | 내용                      | Version | 수정일     | 작성자 |
  | ---- | ------------------------- | ------- | ---------- | ------ |
  | 1    | 초안 작성                 | V1.0    | 2024-04-01 | 홍길동 |
  | 2    | 보완                      | V1.1    | 2024-04-02 | 이순신 |
  | 3    | 2024-04-04 회의 내용 반영 | V1.2    | 2024-04-05 | 이순신 |
  | 4    | 2024-04-05 회의 내용 반영 | V1.3    | 2024-04-06 | 홍길동 |
  | 5    | 2024-04-06 회의 내용 반영 | V1.4    | 2024-04-07 | 이순신 |
  | 6    | 2024-04-07 회의 내용 반영 | V1.5    | 2024-04-08 | 홍길동 |

### 4. UI 요구사항 정의서 작성

UI 요구사항 정의서는 사용자의 요구사항을 확인하고 정리한 문서로, 사용자 요구사항의 UI 적용 여부를 요구사항별로 표시한다.

ex) UI 설계서 : 요구사항 정의서(RFP)

| No   | RFP(Request For Proposal)               | 확정 여부 | 비고                 |
| ---- | --------------------------------------- | --------- | -------------------- |
| 1    | 요구사항1 - 화면에 표현될 기능          | 확정      | 화면 설계 적용       |
| 2    | 요구사항2 - 화면 구성 요소              | 확정      | 화면 설계 적용       |
| 3    | 요구사항3 - 추가적으로 필요한 구성 요소 | 확정      | 화면 설계 적용(1안)  |
| 4    | 요구사항4 - 기능을 표현하기 위한 페이지 | 확정      | 화면 설계 적용       |
| 5    | 요구사항5 - 각 화면 간 이동             | 확정      | 2024-04-04 회의 반영 |
| 6    | 요구사항6 - 공고 및 이벤트 협업 창      | 확정      | 2024-04-07 협의 결정 |

### 5. 시스템 구조 작성

시스템 구조는 UI 요구사항과 UI 프로토타입에 기초하여 전체 시스템의 구조를 설계한 것으로 사용자의 요구사항이 어떻게 시스템에 적용되는지 알 수 있다.

ex) UI 설계서 : UI 시스템 구조

<img src="https://blog.kakaocdn.net/dn/bXEbOe/btq2lBDMmmq/dG46dY5Vcn0OOFoyySnjR1/img.png" alt="img" style="zoom:40%;" />

### 6. 사이트 맵(Site Map) 작성

사이트 맵은 시스템 구조를 바탕으로 사이트에 표시할 콘텐츠를 한 눈에 알아 볼 수 있도록 메뉴별로 구분하여 설계한 것이다.

* 사이트 맵을 작성한 후 사이트 맵의 상세 내용(Site Map Detail)을 표 형태로 작성한다.

  ex) UI 설계서 : 사이트 맵 구조

  <img src="https://blog.kakaocdn.net/dn/MkXCv/btqD1pPkC78/mS0lst3G3yD9DnKTQ032FK/img.png" alt="img" style="zoom:80%;" />

  ex) 사이트 맵 상세 내용(Site Map Detail)

  <img src="https://blog.kakaocdn.net/dn/kGGKx/btqD2c9OL7n/Kz5Y80kE7ledPFC8TGkjqk/img.png" alt="img" style="zoom:80%;" />

### 7. 프로세스 정의서 작성

프로세스 정의서는 사용자 관점에서 사용자가 요구하는 프로세스들을 작업 진행 순서에 맞춰 정리한 것으로 UI의 전체적인 흐름을 파악할 수 있다.

<img src="https://blog.kakaocdn.net/dn/2nA3T/btqD0iQH7sx/U0N9Slr5EkfeeRv4RPfiLk/img.png" alt="img" style="zoom:80%;" />

### 8. 화면 설계

화면 설계는 UI 프로토타입과 UI 프로세스를 참고하여 필요한 화면을 페이지별로 설계한 것이다.

* 화면을 구분하기 위해 화면별 고유ID를 부여하고 별도 표지를 작성한다.

  1. 대표적인 화면들에 대해 포함될 정보, 인터페이스 요소, 레이아웃 등이 표현된 와이어프레임을 대략적으로 스케치한다.

  2. 주요 흐름을 스토리보드 형태로 작성한다. 디스크립션에는 시스템 정보, 인터렉션, 로직, 정책 등 디자인하거나 설계할 때 필요한 사항을 기록한다.

     ex) UI 설계서 : 로그인 페이지 타이틀

     <img src="/home/oem/engineer_information_processing/assets/image-20240424051143612.png" alt="image-20240424051143612" style="zoom:80%;" />

     ex) UI 설계서 : 로그인 페이지 화면 설계

     ![image-20240424051050287](/home/oem/engineer_information_processing/assets/image-20240424051050287.png)

※ cf) : UI 화면 설계의 기본 구성 요소

| 구성 요소       | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 윈도우(Window)  | 키보드나 마우스 등을 통해 데이터 입력 및 결과를 보여주는 화면상의 표시 영역이다. |
| 메뉴(Menu)      | * 화면에서 수행할 기능들을 일정한 형태로 모아놓은 인터페이스이다.<br />* 사용자로 하여금 기능 선택을 수월하게 한다. |
| 아이콘(Icon)    | * 수행하고자 하는 동작, 동작의 대상 등을 조그마한 그림 형태로 표현한 인터페이스이다.<br />* 동일한 사용 환경 안에서는 아이콘의 크기는 동일하나 규칙적인 크기 안에서 제공해야 한다. |
| 포인터(Pointer) | * 입력이 이뤄지는 지점을 알려주는 화면상의 커서이다.<br />* 시스템의 상태를 포인터의 모양으로도 표시한다. |

## 18. UI 유용성 평가

### 1. UI의 유용성 평가

* 유용성(Usability)은 사용자가 시스템을 통해 원하는 목표를 얼마나 효과적으로 달성할 수 있는가에 대한 척도로, UI의 주된 목적은 유용성이 뛰어난 UI를 제작하는 것이다.
* 유용성 평가는 사용자 측면에서 복잡한 시스템을 얼마나 편리하게 사용할 수 있는지를 평가하는 것으로, 시스템의 문제점을 찾아내고 개선 방향을 제시하기 위한 조사 과정이다.
* 유용한 UI를 설계하기 위해서는 UI의 구조, 기능, 가치 등에 대해 사용자가 생각하는 사용자 모형과 시스템 설계자가 만들려고 하는 개발자 모형 간의 차이를 최소화해야 한다.
* 사용자 모형과 개발자 모형 간의 차이가 발생하는 원인
  * 실행 차 : 사용자가 원하는 목적과 실행 기능이 다르기 때문에 발생한다.
  * 평가 차 : 사용자가 원하는 목적과 실행 결과가 다르기 때문에 발생한다.

### 2. 실행 차를 줄이기 위한 UI 설계 원리 검토

#### 1. 사용 의도 파악

사용자의 목적을 명확히 파악한 후 불필요한 기능이나 중복되는 기능이 있는지 확인한다.

#### 2. 행위 순서 규정

* 사용자가 특정 기능을 사용하기 위한 행위 순서를 세분화시켜 순서대로 제시하고, 사용자가 임의로 행위 순서를 변경할 수 있도록 한다.
* 특정 작업을 수행하기 위한 단계는 최소화하고, 다양한 방법을 통해 수행할 수 있도록 설계하며, 사용자의 기존 경험에 비추어 가능한 한 친숙하도록 설계한다.

#### 3. 행위의 순서대로 실행

* 프로세스의 흐름을 직접적으로 파악할 수 있도록 제공함으로써 사용자가 행위 순서대로 실행할 때 어려움이 없어야 한다.
* 작업이 원활하게 진행되도록 과도한 상호 작용은 피한다.
* 사용자가 의도한 행위를 효율적으로 실행할 수 있도록 피드백, 취소 기능, 디폴트 값 등을 적절하게 설정한다.

### 3. 평가 차를 줄이기 위한 UI 설계 원리 검토

#### 1. 수행한 키 조작의 결과를 사용자가 빠르게 지각하도록 유도

사용자가 수행한 행위에 대해 최대한 빨리 반응하도록 설계하고, 사용자가 수행한 행위로 인해 현재 시스템의 변화를 직접적으로 파악 할 수 있도록 피드백해야 한다.

#### 2. 키 조작으로 변화된 시스템의 상태를 사용자가 쉽게 인지하도록 유도

시스템의 상태 정보를 가능한 한 단순하고 이해하기 쉽게 제시해야 한다.

#### 3. 사용자가 가진 원래 의도와 시스템 결과 간의 유사 정도를 사용자가 쉽게 파악하도록 유도

사용자의 의도가 시스템을 통해 충족되었는지, 충족될 수 있는지를 사용자가 쉽게 파악할 수 있도록 설계해야 한다.

## 19. UI 상세 설계

### 1. UI 시나리오 문서 개요

UI 상세 설계는 UI 설계서를 바탕으로 실제 설계 및 구현을 위해 모든 화면에 대한 자세한 설계를 진행하는 단계로, UI 상세 설계를 할 때는 반드시 시나리오를 작성해야 한다.

* UI 시나리오 문서는 사용자 인터페이스의 기능 구조, 대표 화면, 화면 간 인터랙션의 흐름, 다양한 상황에서의 예외 처리 등을 문서로 정리한 것이다.
* UI 시나리오 문서에는 사용자가 최종 목표를 달성하기 위한 방법이 순차적으로 묘사되어 있다.
* UI 설계자 또는 인터랙션 디자이너가 UI 시나리오 문서를 작성하면 그래픽 디자이너가 시나리오를 바탕으로 디자인을 하고 개발자가 UI를 구현한다.

### 2. UI 시나리오 문서 작성 원칙

* 개발자가 전체적인 UI의 기능과 작동 방식을 한눈에 이해할 수 있도록 구체적으로 작성한다. 보통 계층(Tree) 구조 또는 플로차트(Flow Chart) 표기법으로 작성한다.

* 모든 기능에 공통적으로 적용될 UI 요소와 인터랙션을 일반 규칙으로 정의한다.

* 대표 화면에 레이아웃과 그 화면에 속할 기능을 정의한다.

* 인터랙션의 흐름을 정의하며, 화면 간 인터랙션의 순서(Sequence), 분기(Branch), 조건(Condition), 루프(Loop) 등을 명시한다.

* 예외 상황에 대비한 다양한 케이스를 정의한다.

* UI 일반 규칙을 지키면서 기능별 상세 기능 시나리오를 정의한다.

* UI 시나리오 규칙을 지정한다.

  ex) UI 시나리오 작성

  <img src="/home/oem/engineer_information_processing/assets/image-20240424054308853.png" alt="image-20240424054308853" style="zoom:80%;" />

### 3. UI 시나리오 문서 작성을 위한 일반 규칙

UI 시나리오 문서를 작성하면서 적용할 일반적인 규칙은 다음과 같다.

| 구분                                        | 설명                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| 주요 키의 위치와 기능                       | 모든 화면에 공통적으로 배치되는 주요 키의 위치와 기능을 설명한 것으로, 여러 화면 간의 일관성을 보장한다. |
| 공통 UI 요소                                | 체크 박스, 라디오 버튼, 텍스트 박스 등의 UI 요소를 언제, 어떤 형태로 사용할지를 정의하고, 사용자가 조작하면 어떻게 반응하는지 그 흐름을 설명한다. |
| 기본 스크린 레이아웃(Basic Screen Layouts)  | 모든 화면에 공통적으로 나타나는 Titles, Ok/Back, Soft Key, Option, Functional Buttons 등의 위치와 속성을 정의한다. |
| 기본 인터랙션 규칙(Basic Interaction Rules) | 터치 제스처 등에 공통적으로 사용되는 조작 방법과 실행, 이전, 다음, 삭제, 이동 등의 화면 전환 효과 등을 기술한다. |
| 공통 단위 태스크 흐름(Task Flows)           | 많은 기능들에 공통적으로 사용되는 삭제, 검색, 매너 모드 상태 등에 대한 인터랙션 흐름을 설명한다. |
| 케이스 문서                                 | 다양한 상황에서 공통적으로 적용되는 시스템의 동작을 정의한 문서이다.<br />ex) 사운드, 조명, 이벤트 케이스 등 |

※ cf) : UI 요소

* 체크 박스(Check Box)

  여러 개의 선택 상황에서 1개 이상의 값을 선택할 수 있는 버튼이다.

* 라디오 버튼(Radio Button)

  여러 항목 중 하나만 선택할 수 있는 버튼이다.

* 텍스트 박스(Text Box)

  사용자가 데이터를 입력하고 수정할 수 있는 상자이다.

* 콤보 상자(Combo Box)

  이미 지정된 목록 상자에 내용을 표시하여 선택하거나 새로 입력할 수 있는 상자이다.

* 목록 상자(List Box)

  콤보 상자와 같이 목록을 표시하지만 새로운 내용을 입력할 수 없는 상자이다.

### 4. UI 시나리오 문서의 요건

| 요건                    | 내용                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 완전성(Complete)        | * 누락되지 않도록 최대한 상세하게 기술해야 한다.<br />* 해당 시스템의 기능보다는 사용자의 태스크에 초점을 맞춰 기술한다. |
| 일관성(Consistent)      | 서비스 목표, 시스템 및 사용자의 요구사항, UI 스타일 등이 모두 일관성을 유지해야 한다. |
| 이해성(Understandable)  | * 누구나 쉽게 이해할 수 있도록 설명한다.<br />* 불분명하거나 추상적인 표현은 피한다. |
| 가독성(Readable)        | * 표준화된 템플릿 등을 활용하여 문서를 쉽게 읽을 수 있도록 해야 한다.<br />* v1.0, v2.0 등과 같이 문서 인덱스에 대한 규칙이나 목차를 제공한다.<br />* 읽기 쉽도록 줄, 간격, 단락, 들여쓰기 등의 기준을 마련한다.<br />* 시각적인 효과를 위해 여백이나 빈 페이지, 하이라이팅을 일관성 있게 지정한다.<br />* 하이퍼링크 등을 지정하여 문서들이 서로 참조될 수 있도록 지정한다. |
| 수정 용이성(Modifiable) | 시나리오의 수정이나 개선이 쉬워야 한다.                      |
| 추적 용이성(Traceable)  | 변경 사항은 언제, 어떤 부분이 왜 발생했는지 쉽게 추적할 수 있어야 한다. |

### 5. UI 시나리오 문서로 인한 기대 효과

* 요구사항이나 의사소통에 대한 오류가 감소한다.
* 개발 과정에서의 재작업이 감소하고, 혼선이 최소화된다.
* 불필요한 기능을 최소화한다.
* 소프트웨어 개발 비용을 절감한다.
* 개발 속도를 향상시킨다.

## 20. HCI / UX / 감성공학

### 1. HCI(Human Computer Interaction or Interface)

HCI는 사람이 시스템을 보다 편리하고 안전하게 사용할 수 있도록 연구하고 개발하는 학문으로, 최종 목표는 시스템을 사용하는데 있어 최적의 사용자 경험(UX)을 만드는 것이다.

* 원래 HCI는 사람과 컴퓨터의 상호작용을 연구해서 사람이 컴퓨터를 편리하게 사용하도록 만드는 학문이었으나, 대상이 컴퓨터뿐만 아니라 서비스, 디지털 콘텐츠 등으로, 사람도 개인뿐만 아니라 사회나 집단으로 확대되었다.
* HCI는 어떤 제품이 좋은 제품인지, 어떻게 하면 좋은 제품을 만들 수 있는지 등을 연구한다.

### 2. UX(User Exprience)

UX는 사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 경험을 말한다. 단순히 기능이나 절차상의 만족뿐만 아니라 사용자가 참여, 사용, 관찰하고, 상호 교감을 통해서 알 수 있는 가치 있는 경험을 말한다.

* UX는 기술을 효용성 측면에서만 보는 것이 아니라 사용자의 삶의 질을 향상시키는 하나의 방향으로 보는 새로운 개념이다.

* UI가 사용성, 접근성, 편의성을 중시한다면 UX는 이러한 UI를 통해 사용자가 느끼는 만족이나 감정을 중시한다.

* UX의 특징

  * 주관성(Subjectivity)

    사람들의 개인적, 신체적, 인지적 특성에 따라 다르므로 주관적이다.

  * 정황성(Contextuality)

    경험이 일어나는 상황 또는 주변 환경에 영향을 받는다.

  * 총체성(Holistic)

    개인이 느끼는 총체적인 심리적, 감성적인 결과이다.

### 3. 감성공학

감성공학은 제품이나 작업환경을 사용자의 감성에 알맞도록 설계 및 제작하는 기술로, 인문사회과학, 공학, 의학 등 여러 분야의 학문이 공존하는 종합과학이다.

* '감성'을 과학적으로 측정하기 위해서는 생체계측 기술, 감각계측 기술, 센서, 인공지능, 생체제어 기술 등이 요구된다.

* 감성공학의 목적은 인간의 삶을 편리하고 안전하며 쾌적하게 만드는 것이다.

* 감성공학은 인간의 감성을 구체적으로 제품 설계에 적용하기 위해 공학적인 접근 방법을 사용한다.

* 감성공학은 인간의 신체적, 정신적 특성을 배려한 제품 설계에서 더 나아가 인간의 감성까지 고려한다.

* 감성공학은 인간과 컴퓨터의 상호작용을 나타내는 HCI(Human Computer Interaction or Interface) 설계에 인간의 특성과 감성을 반영하였다.

* 감성공학의 요소 기술

  * 기반 기술

    제품 설계에 적용할 인간의 특성을 파악한다.

  * 구현 기술

    인간의 특성에 맞는 인터페이스를 구현한다.

  * 응용 기술

    인간에 맞는지 파악하여 새로운 감성을 만든다.

# 3장. 애플리케이션 설계

## 21. 소프트웨어 아키텍처

### 1. 소프트웨어 아키텍처의 설계

소프트웨어 아키텍처는 소프트웨어의 골격이 되는 기본 구조이자, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다.

* 소프트웨어 개발 시 적용되는 원칙과 지침이며, 이해 관계자들의 의사소통 도구로 활용된다.
* 소프트웨어 아키텍처 설계는 기본적으로 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사항을 구현하는 방법을 찾는 해결 과정이다.
* 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정한다.
* 소프트웨어 아키텍처 설계의 기본 원리로는 모듈화, 추상화, 단계적 분해, 정보은닉이 있다.

> ※ cf) : 상위 설계와 하위 설계
>
> |           | 상위 설계                | 하위 설계                     |
> | --------- | ------------------------ | ----------------------------- |
> | 별칭      | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계          |
> | 설계 대상 | 시스템의 전체적인 구조   | 시스템 내부 구조 및 행위      |
> | 세부 목록 | 구조, DB, 인터페이스     | 컴포넌트, 자료 구조, 알고리즘 |

### 2. 모듈화(Modulatiry)

모듈화란 소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미한다.

* 자주 사용되는 계산식이나 사용자 인증과 같은 기능들을 공통 모듈로 구성하여 프로젝트의 재사용성을 향상시킬 수 있다.
* 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 들고, 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다.

### 3. 추상화(Abstraction)

추상화는 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다.

* 인간이 복잡한 문제를 다룰 때 가장 기본적으로 사용하는 방법으로, 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어서 여러 가지 요인들을 테스트할 수 있다.

* 추상화는 최소의 비용으로 실제 상황에 대처할 수 있고, 시스템의 구조 및 구성을 대략적으로 파악할 수 있게 해준다.

* 추상화의 유형

  | 유형          | 내용                                                         |
  | ------------- | ------------------------------------------------------------ |
  | 과정 추상화   | 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법 |
  | 데이터 추상화 | 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법 |
  | 제어 추상화   | 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법 |

### 4. 단계적 분해(Stepwise Refinement)

단계적 분해는 하향식 설계 전략으로, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다.

* 추상화의 반복에 의해 세분화된다.
* 소프트웨어의 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행한다.

### 5. 정보 은닉(Information Hiding)

정보 은닉은 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법이다.

* 어떤 모듈이 소프트웨어 기능을 수행하는데 반드시 필요한 기능이 있어 정보 은닉된 모듈과 커뮤니케이션할 필요가 있을 때는 필요한 정보만 인터페이스를 통해 주고 받는다.
* 정보 은닉을 통해 모듈을 독립적으로 수행할 수 있고, 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이하다.

### 6. 소프트웨어 아키텍처의 품질 속성

소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 품질 평가 요소들을 시스템 측면, 비즈니스 측면, 아키텍처 측면으로 구분하여 구체화시켜 놓은 것이다.

* 시스템 측면

  | 품질 속성   | 내용                                                         |
  | ----------- | ------------------------------------------------------------ |
  | 성능        | 사용자의 요청과 같은 이벤트가 발생했을 때, 이를 적적하고 빠르게 처리하는 것이다. |
  | 보안        | 허용되지 않은 접근은 막고, 허용된 접근에는 적적한 서비스를 제공하는 것이다. |
  | 가용성      | 장애 없이 정상적으로 서비스를 제공하는 것이다.               |
  | 기능성      | 사용자가 요구한 기능을 만족스럽게 구현하는 것이다.           |
  | 사용성      | 사용자가 소프트웨어를 사용하는데 헤매지 않도록 명확하고 편리하게 구현하는 것이다. |
  | 변경 용이성 | 소프트웨어가 처음 설계 목표와 다른 하드웨어나 플랫폼에서도 동작할 수 있도록 구현하는 것이다. |
  | 확장성      | 시스템의 용량, 처리능력 등을 확장시켰을 때 이를 효과적으로 활용할 수 있도록 구현하는 것이다. |
  | 기타 속성   | 테스트 용이성, 배치성, 안정성 등이 있다.                     |

* 비즈니스 측면

  | 품질 속성        | 내용                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | 시장 적시성      | 정해진 시간에 맞춰 프로그램을 출시하는 것이다.               |
  | 비용과 혜택      | * 개발 비용을 더 투자하여 유연성이 높은 아키텍처를 만들 것인지를 결정하는 것이다.<br />* 유연성이 떨어지는 경우 유지보수에 많은 비용이 소모될 수 있다는 것을 고려해야 한다. |
  | 예상 시스템 수명 | * 시스템을 얼마나 오랫동안 사용할 것인지를 고려하는 것이다.<br />* 수명이 길어야 한다면 시스템 품질의 '변경 용이성', '확장성'을 중요하게 고려해야 한다. |
  | 기타 속성        | 목표 시장 공개 일정, 기존 시스템과의 통합 등이 있다.         |

* 아키텍처 측면

  | 품질 속성      | 내용                                                         |
  | -------------- | ------------------------------------------------------------ |
  | 개념적 무결성  | 전체 시스템과 시스템을 이루는 구성요소들 간의 일관성을 유지하는 것이다. |
  | 정확성, 완결성 | 요구사항과 요구사항을 구현하기 위해 발생하는 제약사향들을 모두 충족시키는 것이다. |
  | 구축 가능성    | 모듈 단위로 구분된 시스템을 적절하게 분배하여 유연하게 일정을 변경할 수 있도록 하는 것이다. |
  | 기타 속성      | 변경성, 시험성, 적응성, 일치성, 대체성 등이 있다.            |

### 7. 소프트웨어 아키텍처의 설계 과정

아키텍처의 설계 과정은 설계 목표 설정, 시스템 타입 결정, 아키텍처 패턴 적용, 서브시스템 구체화, 검토 순으로 진행된다.

1. 설계 목표 설정

   시스템의 개발 방향을 명확히 하기 위해 설계에 영향을 주는 비즈니스 목표, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정한다.

2. 시스템 타입 결정

   시스템과 서브시스템의 타입을 결정하고, 설계 목표와 함께 고려하여 아키텍처 패턴을 설계한다.

3. 아키텍처 패턴 적용

   아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계한다.

4. 서브시스템 구체화

   서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스를 정의한다.

5. 검토

   아키텍처가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지, 설계 기본 원리를 만족하는지 등을 검토한다.

> ※ cf) : 시스템 타입 / 협약에 의한 설계
>
> ###### 시스템 타입
>
> 시스템 타입은 일반적으로 네 가지 타입으로 나눌 수 있다.
>
> * 대화형 시스템
>
>   사용자의 요구가 발생하면 시스템이 이를 처리하고 반응하는 시스템
>
>   예) 온라인 쇼핑몰과 같은 대부분의 웹 어플리케이션
>
> * 이벤트 중심 시스템
>
>   외부의 상태 변화에 따라 동작하는 시스템
>
>   예) 전화, 비상벨 등의 내장 소프트웨어
>
> * 변환형 시스템
>
>   데이터가 입력되면 정해진 작업들을 수행하여 결과를 출력하는 시스템
>
>   예) 컴파일러, 네트워크 프로토콜 등
>
> * 객체 영속형 시스템
>
>   데이터베이스를 사용하여 파일을 효과적으로 저장, 검색, 갱신할 수 있는 시스템
>
>   예) 서버 관리 소프트웨어
>
> ###### 협약(Contract)에 의한 설계
>
> 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것으로, 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세한다.
>
> * 협약에 의한 설계 시 명세에 포함될 조건에는 선행 조건, 결과 조건, 불변 조건이 있다.
>
>   | 조건                     | 내용                                               |
>   | ------------------------ | -------------------------------------------------- |
>   | 선행 조건(Precondition)  | 오퍼레이션이 호출되기 전에 참이 되어야 할 조건     |
>   | 결과 조건(Postcondition) | 오퍼레이션이 수행된 후 만족되어야 할 조건          |
>   | 불변 조건(Invariant)     | 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건 |

## 22. 아키텍처 패턴

### 1. 아키텍처 패턴의 개요

아키텍처 패턴은 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.

* 아키텍처 패턴은 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시한다.
* 아키텍처 패턴에는 서브시스템들과 그 역할이 정의되어 있으며, 서브시스템 사이의 관계와 여러 규칙, 지침 등이 포함되어 있다.
* 아키텍처 패턴을 아키텍처 스타일 또는 표준 아키텍처라고도 한다.
* 아키텍처 패턴의 장점
  * 시행착오를 줄여 개발 시간을 단축시키고, 고품질의 소프트웨어를 생산할 수 있다.
  * 검증된 구조로 개발하기 때문에 안정적인 개발이 가능하다.
  * 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통이 간편해진다.
  * 시스템의 구조를 이해하는 것이 쉬워 개발에 참여하지 않은 사람도 손쉽게 유지 보수를 수행할 수 있다.
  * 시스템의 특성을 개발 전에 예측하는 것이 가능해진다.
* 아키텍처 패턴의 종류에는 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴 등이 있다.

### 2. 레이어 패턴

레이어 패턴은 시스템을 계층으로 구분하여 고정하는 고전적인 방법 중의 하나이다.

* 레이어 패턴은 각각의 서브시스템들이 계층 구조를 이루며, 상위 계층은 하위 계층에 대한 서비스 제공자가 되고, 하위 계층은 상위 계층의 클라이언트가 된다.
* 레이어 패턴은 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어지며, 변경 사항을 적용할 때도 서로 마주보는 두 개의 계층에만 영향을 미치므로 변경 작업이 용이하다.
* 레이어 패턴은 특정 계층만을 교체해 시스템을 개선하는 것이 가능하다.
* 대표적으로 OSI 참조 모델이 있다.

### 3. 클라이언트-서버 패턴

클라이언트-서버 패턴은 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다.

* 클라이언트-서버 패턴에서 사용자는 클라이언트와만 의사소통을 한다. 즉 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스를 제공한다.
* 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 한다.
* 클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적이다.

### 4. 파이프-필터 패턴

파이프-필터 패턴은 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴이다.

* 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이하다.
* 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능하다.
* 파이프-필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 주로 사용된다.
* 대표적으로 UNIX의 쉘이 있다.

### 5. 모델-뷰-컨트롤러 패턴

모델-뷰-컨트롤러 패턴은 서브시스템을 3개의 부분으로 구조화하는 패턴이며, 각 부분의 역할은 다음과 같다.

* 모델(Model)

  서브시스템의 핵심 기능과 데이터를 보관한다.

* 뷰(View)

  사용자에게 정보를 표시한다.

* 컨트롤러(Controller)

  사용자로부터 받은 입력을 처리한다.

* 모델-뷰-컨트롤러 패턴의 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업을 수행할 수 있다.

* 모델-뷰-컨트롤러 패턴에서는 여러 개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합하다.

### 6. 기타 패턴

| 패턴                 | 내용                                                         |
| -------------------- | ------------------------------------------------------------ |
| 마스터-슬레이브 패턴 | * 마스터 컴포넌트에서 슬레이브 컴포넌트로 작업을 분할한 후, 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴이다.<br />* 마스터 컴포넌트는 모든 작업의 주체이고, 슬레이브 컴포넌트는 마스터 컴포넌트의 지시에 따라 작업을 수행하여 결과를 반환한다.<br />* 장애 허용 시스템과 병렬 컴퓨팅 시스템에서 주로 활용된다. |
| 브로커 패턴          | * 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해준다.<br />* 원격 서비스 호출에 응답하는 컴포넌트들이 여러 개 있을 때 적합한 패턴이다.<br />* 분산 환경 시스템에서 주로 활용된다. |
| 피어-투피어 패턴     | * 피어(Peer)를 하나의 컴포넌트로 간주하며, 각 피어는 서비스를 호출하는 클라이언트가 될 수도, 서비스를 제공하는 서버가 될 수도 있는 패턴이다.<br />* 피어-투-피어 패턴에서 클라이언트와 서버는 전형적인 멀티스레딩 방식을 사용한다. |
| 이벤트-버스 패턴     | * 소스가 특정 채널에 이벤트 메시지를 발행(Publish)하면, 해당 채널을 구독(Subscribe)한 리스너들이 메시지를 받아 이벤트를 처리하는 방식이다.<br />* 4가지 주요 컴포넌트<br />- 이벤트를 생성하는 소스<br />- 이벤트를 수행하는 리스너<br />- 이벤트의 통로인 채널<br />- 채널들을 관리하는 버스 |
| 블랙보드 패턴        | * 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 형태로, 컴포넌트들은 검색을 통해 블랙보드에서 원하는 데이터를 찾을 수 있다.<br />* 해결책이 명확하지 않은 문제를 처리하는데 유용한 패턴이다.<br />* 음성 인식, 차량 식별, 신호 해석 등에 주로 활용된다. |
| 인터프리터 패턴      | * 프로그램 코드와 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성된다.<br />* 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트를 설계할 때 사용되어진다. |

## 23. 객체지향(Object-Oriented)

### 1. 객체지향의 개요

객체지향은 현실 세계의 개체(Entity)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 기계적인 부품을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때에도 객체들을 조립해서 작성할 수 있는 기법을 말한다.

* 객체지향 기법은 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있다.
* 객체지향은 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다.
* 객체지향은 복잡한 구조를 단계적, 계층적으로 표현하고, 멀티미디어 데이터 및 병렬 처리를 지원한다.
* 객체지향은 현실 세계를 모형화하므로 사용자와 개발자가 쉽게 이해할 수 있다.
* 객체지향의 주요 구성 요소와 개념에는 객체, 클래스, 캡슐화, 상속, 다형성, 연관성이 있다.

### 2. 객체

객체는 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈이다.

| 구성요소 | 내용                                                         |
| -------- | ------------------------------------------------------------ |
| 데이터   | * 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 나타낸다.<br />* 속성, 상태, 변수, 상수, 자료 구조라고도 한다. |
| 함수     | * 객체가 수행하는 기능으로 객체가 갖는 데이터(속성, 상태)를 처리하는 알고리즘이다.<br />* 객체의 상태를 참조하거나 변경하는 수단이 되는 것으로 메소드, 서비스, 동작, 연산이라고도 한다. |

* 객체의 특성
  * 객체는 독립적으로 식별 가능한 이름을 가지고 있다.
  * 객체가 가질 수 있는 조건을 상태라고 하는데, 일반적으로 상태는 시간에 따라 변한다.
  * 객체와 객체는 상호 연관성에 의한 관계가 형성된다.
  * 객체가 반응할 수 있는 메시지의 집합을 행위라고 하며, ㄱ개체는 행위의 특징을 나타낼 수 있다.
  * 객체는 일정한 기억장소를 가지고 있다.
* 객체의 메소드는 다른 객체로부터 메시지르 ㄹ받았을 때 정해진 기능을 수행한다.

### 3. 클래스

클래스는 공통된 속성과 연산(행위)을 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미한다.

* 클래스는 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
* 클래스에 속한 각각의 객체를 인스턴스라 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화라고 한다.
* 동일 클래스에 속한 각각의 객체(인스턴스)들은 공통된 속성과 행위를 가지고 있으면서, 그 속성에 대한 정보가 서로 달라서 동일 기능을 하는 여러 가지 객체를 나타내게 된다.
* 최상위 클래스는 상위 클래스를 갖지 않는 클래스를 의미한다.
* 슈퍼 클래스는 특정 클래스의 상위 클래스이고 서브 클래스는 특정 클래스의 하위 클래스를 의미한다.

### 4. 캡슐화

캡슐화는 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미한다.

* 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐되어 외부에서의 접근이 제한적이기 때문에 외부모듈의 변경으로 인한 파급 효과가 적다.
* 캡슐화된 객체들은 재사용이 용이하다.
* 객체들 간의 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다.

### 5. 상속

상속은 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것이다.

* 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용할 수 있다.

* 하위 클래스는 상위 클래스로부터 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용할 수 있다.

* 상위 클래스의 속성과 연산을 하위 클래스가 사용할 수 있기 때문에 객체와 클래스의 재사용, 즉 소프트웨어의 재사용을 높이는 중요한 개념이다.

* 다중 상속

  한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것이다.

### 6. 다형성

다형성은 메시지에 의해 객체(혹은 클래스)가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미한다.

* 객체(클래스)들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다.
* 응용 프로그램 상에서나 하나의 함수나 연산자가 두 개 이상의 서로 다른 클래스의 인스턴스들을 같은 클래스에 속한 인스턴스처럼 수행할 수 있도록 하는 것이다.

### 7. 연관성

연관성은 두 개 이상의 객체(혹은 클래스)들이 상호 참조하는 관계를 말하며 종류는 다음과 같다.

| 종류           | 의미            | 특징                                                   |
| -------------- | --------------- | ------------------------------------------------------ |
| is member of   | 연관화          | 2개 이상의 객체가 상호 관련되어 있음을 의미            |
| is instance of | 분류화          | 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것      |
| is part of     | 집단화          | 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것 |
| is a           | 일반화          | 공통적인 성질들로 추상화한 상위 객체를 구성하는 것     |
| is a           | 특수화 / 상세화 | 상위 객체를 구체화하여 하위 객체를 구성하는 것         |

## 24. 객체지향 분석 및 설계

### 1. 객체지향 분석의 개념

객체지향 분석(OOA : Object Oriented Analysis)은 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 이와 연관된 속성과 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업이다.

* 소프트웨어를 개발하기 위한 비즈니스(업무)를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석한다.
* 분석가에게 주요한 모델링 구성 요소인 클래스, 객체, 속성, 연산들을 표현해서 문제를 모형화할 수 있게 해준다.
* 객체는 클래스로부터 인스턴스화되고, 이 클래스를 식별하는 것이 객체지향 분석의 주요한 목적이다.

### 2. 객체지향 분석의 방법론

* Rumbaugh(럼바우) 방법

  가장 일반적으로 사용되는 방법으로 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법

* Booch(부치) 방법

  미시적, 거시적 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석, 식별하고 클래스의 속성과 연산을 정의

* Jacobson 방법

  Use Case를 강조하여 사용하는 분석 방법

* Coad와 Yourdon 방법

  E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법

* Wirfs-Brock 방법

  분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법

### 3. 럼바우 분석 기법

모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법으로, 객체 모델링 기법(OMT, Object-Modeling Technique)이라고도 한다.

* 분석 활동은 '객체 모델링 → 동적 모델링 → 기능 모델링' 순으로 통해 이루어진다.

  | 모델링 종류                      | 내용                                                         |
  | -------------------------------- | ------------------------------------------------------------ |
  | 객체 모델링(Object Modeling)     | 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것 |
  | 동적 모델링(Dynamic Modeling)    | 상태 다이어그램(상태도)을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링 |
  | 기능 모델링(Functional Modeling) | 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링 |

### 4. 객체지향 설계 원칙

객체지향 설계 원칙은 시스템 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜야 할 다섯가지 원칙으로, 다섯 가지 원칙의 앞 글자를 따 SOLID 원칙이라고도 불린다.

| 원칙 종류                                                  | 내용                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| 단일 책임 원칙(SRP, Single Responsibility Principle)       | * 객체는 단 하나의 책임만 가진다.<br />* 응집도는 높고, 결합도는 낮게 설계 |
| 개발-폐쇄 원칙(OCP, Open-Closed Principle)                 | * 기존 코드를 변경하지 않고 기능을 추가할 수 있도록 설계<br />* 공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화하는 방법이 대표적 |
| 리스코프 치환 원칙(LSP, Liskov Substitution Principle)     | * 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행<br />* 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행 |
| 인터페이스 분리 원칙(ISP, Interface Segregation Principle) | * 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다.<br />* 단일 책임 원칙이 객체가 갖는 하나의 책임이라면, 인터페이스 분리 원칙은 인터페이스가 갖는 하나의 책임이다. |
| 의존 역전 원칙(DIP, Dependency Inversion Principle)        | * 각 객체들 간의 의존 관계가 성립될 때, 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다.<br />* 일반적으로 인터페이스를 활용하면 이 원칙은 준수된다. |

## 25. 모듈

### 1. 모듈의 개요

모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용된다.

* 단독으로 컴파일 가능, 재사용 가능
* 독립성을 가짐, 과도한 상호작용을 배제
* 독립성이 높을수록 다른 모듈들에게 영향을 미치지 않으며, 오류가 발생해도 손쉽게 해결
* 독립성은 결합도와 응집도에 의해 측정되며, 독립성을 높이려면 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게 만들어야 한다.

### 2. 결합도(Coupling)

모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미

* 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다.

* 결합도가 강하면 시스템 구현 및 유지보수 작업이 어렵다.

* 결합도의 종류

  | 결합도 종류(아래로 갈수록 결합도 강함) | 내용 및 특징                                                 |
  | -------------------------------------- | ------------------------------------------------------------ |
  | 자료 결합도(Data Coupling)             | * 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도<br />* 다른 모듈을 호출하면 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려주는 방식.<br />* 모듈 간의 내용을 전혀 알 필요가 없는 상태로서 한 모듈의 내용을 변경하더라도 다른 모듈에는 전혀 영향을 미치지 않는 가장 바람직한 결합도 |
  | 스탬프(검인) 결합도(Stamp Coupling)    | * 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도<br />* 두 모듈이 동일한 자료 구조를 조회하는 경우의 결합도<br />* 자료 구조의 포맷이나 구조의 변화는 그것을 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈에까지도 영향을 미치게 된다. |
  | 제어 결합도(Control Coupling)          | * 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소(Function Code, Switch, Tag, Flag)를 전달하는 결합도<br />* 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈 간에 분리되어 설계된 경우에 발생<br />* 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도현상이 발생하게 된다. |
  | 외부 결합도(External Coupling)         | * 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도<br />* 참조되는 데이터의 범위를 각 모듈에서 제한할 수 있다. |
  | 공통(공유) 결합도(Common Coupling)     | * 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도<br />* 공통 데이터 영역을 조금만 변경하더라도 이를 사용하는 모든 모듈에 영향을 미치므로 독립성을 약하게 만듦 |
  | 내용 결합도(Content Coupling)          | * 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도<br />* 한 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우에도 내용 결합도에 해당 |

  ### 3. 응집도(Cohesion)

  정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등의 모듈 내부 요소의 서로 관련되어 있는정도, 즉 모듈의 독립적인 기능으로 정의되어 있는 정도를 의미

  * 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다.

  * 응집도의 종류

    | 응집도의 종류(아래로 갈수록 응집도가 약함)  | 내용 및 특징                                                 |
    | ------------------------------------------- | ------------------------------------------------------------ |
    | 기능적 응집도(Functional Cohesion)          | 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도 |
    | 순차적 응집도(Sequential Cohesion)          | 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 |
    | 교환(통신)적 응집도(Communication Cohesion) | 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도 |
    | 절차적 응집도(Procedural Cohesion)          | 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도 |
    | 시간적 응집도(Temporal Cohesion)            | 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도 |
    | 논리적 응집도(Logical Cohesion)             | 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도 |

### 4. 팬인(Fan-In) / 팬아웃(Fan-Out)

* 팬인은 어떤 모듈을 제어(호출)하는 모듈의 수를 나타낸다.
* 팬아웃은 어떤 모듈에 의해 제어(호출)되는 모듈의 수를 나타낸다.
* 팬인과 팬아웃을 분석하여 시스템 복잡도를 알 수 있다.
* 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되었다고 볼 수 있으나, 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요
* 팬아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토하고, 단순화시킬 수 있는지 여부에 대한 검토 필요
* 시스템의 복잡도를 최적화하려면 팬인은 높게, 팬아웃은 낮게 설계

> ※ cf) : N-S 차트(Nassi-Schneiderman Cahrt)
>
> N-S 차트는 논리의 기술에 중점을 둔 도형을 이용한 표현 방법으로 박스 다이어그램, Chapin Chart라고도 한다.
>
> * 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조를 표현
> * GOTO나 화살표를 사용하지 않음
> * 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합
> * 선택과 반복 구조를 시각적으로 표현
> * 이해가 쉽고 코드 변환이 용이
> * 읽기는 쉽지만 작성하기 어려우며, 임의로 제어를 전이하는 것이 불가능
> * 총체적인 구조 표현과 인터페이스를 나타내기 어려움
> * 단일 입구와 단일 출구로 표현

## 26. 공통 모듈

### 1. 공통 모듈의 개요

여러 프로그램에서 공통적으로 사용할 수 있는 모듈

* 자주 사용되는 계산식, 매번 필요한 사용자 인증과 같은 기능 등

* 모듈의 재사용성 확보와 중복 개발 회피를 위해 설꼐 과정에서 공통 부분을 식별하고 명세를 작성할 필요가 있다.

* 공통 모듈을 구현할 때는 다른 개발자들이 해당 기능을 명확히 이해할 수 있도록 다음 명세 기법을 준수해야 한다.

  | 준수 사항            | 내용                                                         |
  | -------------------- | ------------------------------------------------------------ |
  | 정확성(Correctness)  | 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성 |
  | 명확성(Clarity)      | 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성 |
  | 완전성(Completeness) | 시스템 구현을 위해 모든 것을 기술                            |
  | 일관성(Consistency)  | 공통 기능들 간 상호 충돌이 발생하지 않도록 작성              |
  | 추적성(Traceability) | 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성 |

### 2. 재사용(Reuse)

비용과 개발 시간을 절약하기 위해 이미 개발된 기능들을 파악하고 재구성하여 새로운 시스템 또는 기능 개발에 사용하기 적합하도록 최적화 시키는 작업

* 재사용을 위해서는 누구나 이해하기 쉽고 사용 가능하도록 사용법을 공개해야 한다.

* 재사용되는 대상은 외부 모듈과의 결합도는 낮고, 응집도는 높아야 한다.

* 재사용 규모에 따른 분류

  | 분류         | 내용                                                         |
  | ------------ | ------------------------------------------------------------ |
  | 함수와 객체  | 클래스나 메소드 단위의 소스 코드를 재사용한다.               |
  | 컴포넌트     | 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용한다. |
  | 애플리케이션 | 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용한다. |

### 3. 효과적인 모듈 설계 방안

* 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높인다.
* 모듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지시킨다.
* 복잡도와 중복성을 줄이고 일관성을 유지시킨다.
* 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다.
* 유지보수가 용이해야 한다.
* 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해한다.
* 하나의 입구와 하나의 출구를 갖도록 해야 한다.
* 인덱스 번호나 기능 코드들이 전반적인 처리 논리 구조에 예기치 못한 영향을 끼치지 않도록 모듈 인터페이스를 설꼐해야 한다.
* 효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야 한다.

## 27. 코드

### 1. 코드의 개요

컴퓨터를 이용하여 자료를 처리하는 과정에서 분류, 조합 및 집계를 용이하게 하고, 특정 자료의 추출을 쉽게 하기 위해서 사용하는 기호이다.

* 코드는 정보를 신속, 정확, 명료하게 전달할 수 있게 한다.

* 코드는 일정한 규칙에 따라 작성되며, 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미친다.

* 일반적인 코드의 예로 주민등록번호, 학번, 전화번호 등이 있다.

* 코드의 주요 기능에는 식별 기능, 분류 기능, 배열 기능, 표준화 기능, 간소화 기능이 있다.

  | 기능        | 내용                                                         |
  | ----------- | ------------------------------------------------------------ |
  | 식별 기능   | 데이터 간의 성격에 따라 구분이 가능하다.                     |
  | 분류 기능   | 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 할 수 있다. |
  | 배열 기능   | 의미를 부여하여 나열할 수 있다.                              |
  | 표준화 기능 | 다양한 데이터를 기준에 맞추어 표현할 수 있다.                |
  | 간소화 기능 | 복잡한 데이터를 간소화할 수 있다.                            |

### 2. 코드의 종류

| 종류                                      | 내용                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| 순차 코드(Sequence Code)                  | 자료의 발생 순서 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법으로, 순서 코드 또는 일련번호 코드라고도 한다. |
| 블록 코드(Block Code)                     | 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법으로, 구분 코드라고도 한다. |
| 10진 코드(Decimal Code)                   | 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법으로, 도서 분류식 코드라고도 한다. |
| 그룹 분류 코드(Group Classification Code) | 코드화 대상 항목을 일정 순서에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법 |
| 연상 코드(Mnemoric Code)                  | 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법이다. |
| 표와 숫자 코드(Significant Digit Code)    | 코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법으로, 유효 숫자 코드라고도 한다. |
| 합성 코드(Combined Code)                  | 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법이다. |

### 3. 코드 부여 체계

이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식

* 코드 부여 체계는 각 개체에 유일한 코드를 부여하여 개체들의 식별 및 추출을 용이하게 한다.
* 코드를 부여하기 전에 각 단위 시스템의 고유한 코드와 개체를 나타내는 코드 등이 정의되어야 한다.
* 코드 부여 체계를 담당하는 자는 코드의 자릿수와 구분자, 구조 등을 상세하게 명시해야 한다.

## 28. 디자인 패턴

### 1. 디자인 패턴의 개요

각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다.

* 디자인 패턴은 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있다.
* 개발 과정 중에 문제가 발생하면 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다(바퀴를 다시 발명하지 마라).
* 디자인 패턴은 한 패턴에 변형을 가하거나 특정 요구사항을 반영하면 유사한 형태의 다른 패턴으로 변화하는 특징이 있다.
* GoF 디자인 패턴은 수많은 디자인 패턴들 중 가장 일반적인 사례에 적용될 수 있는 패턴들을 분류하여 정리함으로써, 지금까지도 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴이다.
* GoF 디자인 패턴은 유형에 따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성된다.

> ※ cf) : 아키텍처 패턴 vs 디자인 패턴
>
> 아키텍처 패턴과 디자인 패턴은 모두 소프트웨어 설계를 위한 참조 모델이지만 다음과 같은 차이가 있다.
>
> * 아키텍처 패턴은 디자인 패턴보다 상위 수준의 설계에 사용된다.
> * 아키텍처 패턴이 전체 시스템의 구조를 설계하기 위한 참조 모델이라면, 디자인 패턴은 서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델이다.
> * 몇몇 디자인 패턴은 특정 아키텍처 패턴을 구현하는데 유용하게 사용된다.

### 2. 디자인 패턴 사용의 장단점

* 범용적인 코딩 스타일로 인해 구조 파악이 용이하다.
* 객체지향 설계 및 구현의 생산성을 높이는 데 적합하다.
* 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약된다.
* 초기 투자 비용이 부담될 수 있다.
* 개발자 간의 원활한 의사소통이 가능하다.
* 설계 변경 요청에 대한 유연한 대처가 가능하다.
* 객체지향을 기반으로 한 설계와 구현을 다루므로 다른 기반의 애플리케이션 개발에는 적합하지 않다.

### 3. 생성 패턴(Creational Pattern)

생성 패턴은 객체의 생성과 관련된 패턴으로 총 5개의 패턴이 있다.

* 생성 패턴은 객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해준다.

  | 생성 패턴                     | 내용                                                         |
  | ----------------------------- | ------------------------------------------------------------ |
  | 추상 팩토리(Abstract Factory) | * 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다.<br />* 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능하다. |
  | 빌더(Builder)                 | * 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성한다.<br />* 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다. |
  | 팩토리 메소드(Factory Method) | * 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다.<br />* 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.<br />* 가상 생성자(Virtual Constructor) 패턴이라고도 한다. |
  | 프로토타입(Prototype)         | * 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.<br />* 일반적인 방법으로 객체를 생성하여, 비용이 큰 경우 주로 이용한다. |
  | 싱글톤(Singleton)             | * 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.<br />* 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있다. |

### 4. 구조 패턴(Structural Pattern)

클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴으로 총 7개의 패턴이 있다.

* 구조 패턴은 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.

  | 구조 패턴               | 내용                                                         |
  | ----------------------- | ------------------------------------------------------------ |
  | 어댑터(Adapter)         | * 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴이다.<br />* 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용한다. |
  | 브리지(Bridge)          | * 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴이다.<br />* 기능과 구현을 두 개의 별도 클래스로 구현한다. |
  | 컴포지트(Composite)     | * 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴이다.<br />* 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있다. |
  | 데코레이터(Decorator)   | * 객체 간의 결합을 통해 능동적으로 기능을 확장할 수 있는 패턴이다.<br />* 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현한다. |
  | 퍼싸드(Facade)          | * 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴이다.<br />* 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요하다. |
  | 플라이웨이트(Flyweight) | * 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴이다.<br />* 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있다. |
  | 프록시(Proxy)           | * 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴이다.<br />* 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용한다. |

### 5. 행위 패턴(Behavioral Pattern)

클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로 총 11개의 패턴이 있다.

* 행위 패턴은 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와준다.

  | 행위 패턴                          | 내용                                                         |
  | ---------------------------------- | ------------------------------------------------------------ |
  | 책임 연쇄(Chain of Responsibility) | * 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴이다.<br />* 요청을 처리할 수 있는 각 객체들이 고리로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어간다. |
  | 커맨드(Command)                    | * 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴이다.<br />* 요청에 사용되는 각종 명령어들을 추상 클래스와구체 클래스로 분리하여 단순화한다. |
  | 인터프리터(Interpreter)            | * 언어에 문법 표현을 정의하는 패턴이다.<br />* SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용한다. |
  | 반복자(Iterator)                   | * 자료 구조와 같은 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴이다.<br />* 내부 표현 방법의 노출 없이 순차적인 접근이 가능하다. |
  | 중재자(Mediator)                   | * 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴<br />* 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있다. |
  | 메멘토(Memento)                    | * 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴이다.<br />* Ctrl + Z와 같은 되돌리기 기능을 개발할 때 주로 이용한다. |
  | 옵서버(Observer)                   | * 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴이다.<br />* 주로 분산된 시스템 간에 이벤트를 생성, 발행(Publish)하고, 이를 수신(Subscribe)해야 할 때 이용한다. |
  | 상태(State)                        | * 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴이다.<br />* 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리한다. |
  | 전략(Strategy)                     | * 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴이다.<br />* 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변형이 가능하다. |
  | 탬플릿 메소드(Template Method)     | * 상위 클래스에서 골격을 정의하고, 하위 클래스에 세부 처리를 구체화하는 구조의 패턴이다.<br />* 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해준다. |
  | 방문자(Visitor)                    | * 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴<br />* 분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행한다. |

# 4장. 인터페이스 설계

## 29. 시스템 인터페이스 요구사항 분석

### 1. 시스템 인터페이스 요구사항 구성

시스템 인터페이스는 독립적으로 떨어져 있는 시스템들끼리 서로 연동하여 상호 작용하기 위한 접속 방법이나 규칙을 의미한다.

* 시스템 인터페이스 요구사항은 개발을 목표로 하는 시스템과 외부 시스템을 연동하는데 필요한 시스템 인터페이스에 대한 요구사항을 기술한 것이다.
* 시스템 인터페이스 요구사항 명세서에는 인터페이스 이름, 연계 대상 시스템, 연계 범위 및 내용, 연계 방식, 송신 데이터, 인터페이스 주기, 기타 고려사항 등이 포함되어야 한다.

> ※ cf) 요구사항 명세서
>
> 요구사항 명세서는 프로젝트 개발 시 기업이나 업체가 요구하는 사항들을 구체화하여 명세화한 문서로, 시스템 기능, 데이터, 인터페이스, 품질 등의 요구사항 단위별로 작성한다.
>
> ![img](/home/oem/engineer_information_processing/assets/image.png)
>
> 1. 인터페이스 이름
> 2. 연계 대상 시스템
> 3. 연계 범위 및 내용
> 4. 송신 데이터
> 5. 연계 방식
> 6. 인터페이스 추가
> 7. 기타 고려사항

### 2. 시스템 인터페이스 요구사항 분석

시스템 인터페이스 요구사항 분석은 요구사항 명세서에서 요구사항을 기능적 요구사항과 비기능적 요구사항으로 분류하고 조직화하여 요구사항 명세를 구체화하고 이를 이해관계자에게 전달하는 일련의 과정이다.

* 요구사항 분석은 소프트웨어 요구사항 분석 기법을 적절히 이용한다.
* 요구사항의 분해가 필요한 경우 적절한 수준으로 세분화한다.
* 요구사항 분석 시 누락된 요구사항이나 제한조건을 추가한다.
* 요구사항에 대한 상대적 중요도를 평가하여 우선순위를 부여한다.

### 3. 시스템 인터페이스 요구사항 분석 절차

시스템 인터페이스 요구사항 분석 절차는 다음과 같다.

1. 소프트웨어 요구사항 목록에서 시스템 인터페이스 관련 요구사항을 선별하여 별도로 시스템 인터페이스 요구사항 목록을 만든다.

2. 시스템 인터페이스와 관련된 요구사항 및 아키텍처 정의서, 현행 시스템의 대내외 연계 시스템 현황 자료 등 시스템 인터페이스 요구사항과 관련된 자료를 준비한다.

3. 시스템 인터페이스에 대한 요구사항 명세서를 확인하여 기능적인 요구사항과 비기능적인 요구사항으로 분류한다.

   ex) 다음은 회계 관련 시스템의 요구사항 명세서에서 시스템 인터페이스 관련 요구사항을 기능적/비기능적 요구사항으로 분류한 것이다.

   ![img](https://velog.velcdn.com/images/alpaka206/post/f84aa65d-8f47-4026-a5ca-de975a12e8d4/image.png)

4. 시스템 인터페이스 요구사항 명세서와 시스템 인터페이스 요구사항 목록 및 기타 관련 자료들을 비교하여 요구사항을 분석하고 내용을 추가하거나 수정한다.

5. 추가 및 수정한 시스템 인터페이스 요구사항 명세서와 시스템 인터페이스 요구사항 목록을 관련 이해관계자에게 전달한다.

## 30. 인터페이스 요구사항 검증

### 1. 요구사항 검증(Requirements Verification)

요구사항 검증은 인터페이스의 설계 및 구현 전에 사용자들의 요구사항이 요구사항 명세서에 정확하고 완전하게 기술되었는지 검토하고 개발 범위의 기준인 베이스라인을 설정하는 것이다.

* 인터페이스의 설계 및 구현 중에 요구사항 명세서의 오류가 발견되어 이를 수정할 경우 많은 비용이 소요되므로 프로젝트에서 요구사항 검증은 매우 중요하다.
* 인터페이스 요구사항 검증은 '요구사항 검토 계획 수립 → 검토 및 오류 수정 → 베이스라인 설정' 순으로 수행한다.

### 2. 인터페이스 요구사항 검토 계획 수립

프로젝트 이해관계자들이 프로젝트 품질 관리 계획을 참조하여 다음과 같이 인터페이스 요구사항 검토 계획을 수립한다.

| 수립 항목         | 내용                                                         |
| ----------------- | ------------------------------------------------------------ |
| 검토 기준 및 방법 | 프로젝트의 규모와 참여 인력, 검토 기간 등을 고려하여 검토 기준 및 방법을 정한다. |
| 참여자            | 프로젝트 규모에 따라 이해관계자들을 파악하여 프로젝트 관리자, 품질 관리자, 인터페이스 분석가, 소프트웨어 아키텍트, 시스템 사용자, 테스트 관리자 등 요구사항 검토 참여자를 선정한다. |
| 체크리스트        | 완전성, 일관성, 명확성 등의 항목을 점검할 수 있는 요구사항 검토 체크리스트를 작성한다. |
| 관련 자료         | 인터페이스 요구사항 목록, 인터페이스 요구사항 명세서, 현행 및 표준 시스템 구성도 등 인터페이스 요구사항 검토에 필요한 자료들을 준비한다. |
| 일정              | 인터페이스 요구사항 검토 일정을 정한다.                      |

* 검토 계획이 수립되면 인터페이스 요구사항 검토 참여자들에게 검토 관련 자료와 일정 등을 전달한다.

### 3. 인터페이스 요구사항 검토 및 오류 수정

인터페이스 요구사항 검토는 검토 체크리스트의 항목에 따라 인터페이스 요구사항 명세서를 검토하는 것이다.

* 요구사항 검토 시 오류가 발견되면 오류를 수정할 수 있도록 오류 목록과 시정 조치서를 작성한다.
* 오류 수정과 요구사항 승인 절차를 진행할 수 있도록 요구사항 검토 결과를 검토 관련자들에게 전달한다.
* 시정 조치서를 작성한 경우 시정 조치가 완료되었는지 확인하여 시정 조치가 완료되면 인터페이스 요구사항 검토 작업을 완료한다.

### 4. 인터페이스 요구사항 베이스라인 설정

인터페이스 요구사항 검토를 통해 검증된 인터페이스 요구사항은 프로젝트 관리자와 주요 의사 결정자에게 공식적으로 승인 받는다.

* 소프트웨어 설계 및 구현을 위해 요구사항 명세서의 베이스라인을 설정한다.

### 5. 요구사항 검증 방법

* 요구사항 검토(Requirements Review)

  요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 결함 여부를 검토 담당자들이 수작업으로 분석하는 방법으로, 동료검토, 워크스루, 인스펙션 등이 있다.

  | 검토 방법              | 내용                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | 동료검토(Peer Review)  | 요구사항 명세서 작성자가 명세서 내용을 직접 설명하고 동료들이 이를 들으면서 결함을 발견하는 형태의 검토 방법 |
  | 워크스루(Walk Through) | 검토 회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토 방법이다. |
  | 인스펙션(Inspection)   | 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견하는 형태의 검토 방법이다. |

* 프로토타이핑(Prototyping)

  사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품(Prototype)을 만들어 최종 결과물을 예측한다.

* 테스트 설계

  요구사항은 테스트할 수 있도록 작성되어야 하며, 이를 위해 테스트케이스(Test Case)를 생성하여 이후에 요구사항이 현실적으로 테스트 가능한지를 검토한다.

* CASE(Computer Aided Software Engineering) 도구 활용

  일관성 분석(Consistency Analysis)를 통해 요구사항 변경사항의 추적 및 분석, 관리하고, 표준 준수 여부를 확인한다.

### 6. 인터페이스 요구사항 검증의 주요 항목

인터페이스 요구사항 검증은 다음과 같은 항목들을 중심으로 수행한다.

* 완전성(Completeness)

  사용자의 모든 요구사항이 누락되지 않고 완전하게 반영되어 있는가

* 일관성(Consistency)

  요구사항이 모순되거나 충돌되는 점 없이 일관성을 유지하고 있는가

* 명확성(Unambiguity)

  모든 참여자가 요구사항을 명확히 이해할 수 있는가

* 기능성(Functionality)

  요구사항이 '어떻게(How to)'보다 '무엇을(What)'에 중점을 두고 있는가

* 검증 가능성(Verifiability)

  요구사항이 사용자의 요구를 모두 만족하고, 개발된 소프트웨어가 사용자의 요구 내용과 일치하는지를 검증할 수 있는가

* 추적 가능성(Traceability)

  요구사항 명세서와 설계서를 추적할 수 있는가?

* 변경 용이성(Easily Changeable)

  요구사항 명세서의 변경이 쉽도록 작성되었는가?

## 31. 인터페이스 시스템 식별

### 1. 개발 시스템 식별

개발 시스템을 식별하는 것은 인터페이스 관련 자료들을 기반으로 개발하고자 하는 시스템의 상세 식별 정보를 정의하고 목록을 작성하는 것이다.

*ex) 개발할 시스템 목록*

| 구분 | 시스템 한글명 | 시스템 영문명 | 시스템 설명                                      | 시스템 레벨 | 상위 시스템 | 설치 위치 |
| ---- | ------------- | ------------- | ------------------------------------------------ | ----------- | ----------- | --------- |
| 내부 | 고객          | CUST          | 고객 정보를 통합 관리하는 시스템                 | 1           |             | IN1       |
| ``   | 고객관계관리  | CRM           | 고객 정보를 분석하여 마케팅 등에 활용하는 시스템 | 1.1         | CUST        | IN2       |
| ``   | 홈페이지      | HOME          | 고객의 계약 조회 등 온라인 업무 지원             | 2           |             | IN3       |

> ※ cf) : 인터페이스 관련 자료
>
> 인터페이스 관련 자료에는 개발할 시스템에 대한 업무 정의서, 시스템 아키텍처 정의서, 유스케이스 정의서, 현행 시스템에 대한 인터페이스 요구사항 명세서 및 목록, 대내외 연계 시스템 목록, 연계 대상 시스템에 대한 정의서 및 인터페이스 목록 등이 있다.
>
> * 시스템 아키텍처
>
>   시스템 내부에서 각각의 하위 시스템들이 어떠한 관계로 상호작용하는지 파악할 수 있도록 구성이나 동작 원리를 나타내는 것
>
> * 유스케이스(Use Case)
>
>   사용자의 요구사항을 기능 단위로 표현하는 것

### 2. 내·외부 시스템 식별

내외부 시스템을 식별하는 것은 인터페이스 관련 자료들을 기반으로 개발할 시스템과 연계할 내외부 시스템들의 상세 식별 정보를 정의하고 목록을 작성하는 것이다.

*ex) 개발할 시스템과 연계할 내외부 시스템의 목록*

| 구분 | 시스템 한글명 | 시스템 영문명 | 시스템 설명                             | 시스템 레벨 | 상위 시스템 | 설치 위치 |
| ---- | ------------- | ------------- | --------------------------------------- | ----------- | ----------- | --------- |
| 내부 | 회계          | ACC           | 고객의 회계를 관리하는 대내 연계 시스템 | 3           |             | IN4       |
| 외부 | 길벗은행      | ABK           | 길벗은행의 대외 연계 시스템             |             |             |           |
| ``   | 길벗카드      | BCD           | 길벗카드사의 대외 연계 시스템           |             |             |           |

### 3. 내·외부 시스템 환경 및 관리 주체 식별

* 내외부 시스템 환경은 연계할 시스템 접속에 필요한 IP 또는 URL, Port 정보 등 시스템의 실제 운용 환경을 의미한다.
* 내외부 시스템 관리 주체는 하드웨어를 실제적으로 관리하는 담당자를 의미한다.
* 인터페이스 관련 자료들을 기반으로 내외부 시스템의 실제 운용 환경과 하드웨어 관리 주체를 확인한다.

*ex)  내외부 연계 시스템 운용 환경 정보 및 하드웨어 관리 주체*

| 구분 | 시스템 ID | 시스템 한글명 | 시스템 영문명 | 시스템 설명                                      | ... 중략 | IP / URL | Port  | 담당자 |
| ---- | --------- | ------------- | ------------- | ------------------------------------------------ | -------- | -------- | ----- | ------ |
| 내부 | ACS-001   | 고객          | CUST          | 고객 정보를 통합 관리하는 시스템                 | ...      | IP1      | 40001 | 김상욱 |
| ``   | ACS-002   | 고객관계 관리 | CRM           | 고객 정보를 분석하여 마케팅 등에 활용하는 시스템 | ...      | IP2      | 40001 | 임선호 |
| ``   | ACS-003   | 홈페이지      | HOME          | 고객의 계약 조회 등 온라인 업무 지원             | ...      | IP3      | 40001 | 황진주 |
| ``   | ACS-004   | 회계          | ACC           | 고객의 회의를 관리하는 대내 연계 시스템          | ...      | IP4      | 40001 | 김선길 |
| 외부 | ACS-005   | 길벗은행      | ABK           | 길벗은행의 대외 연계 시스템                      | ...      | IP5      |       | 이가영 |
| ``   | ACS-006   | 길벗카드      | BCD           | 길벗카드사의 대외 연계 시스템                    | ...      | IP6      |       | 신중희 |

### 4. 내·외부 시스템 네트워크 연결 정보 식별

내외부 시스템 네트워크 연결 정보는 시스템 로그인 및 DB 정보를 의미한다.

* 인터페이스 관련 자료들을 기반으로 내외부 시스템을 연계하는데 필요한 네트워크 연결 정보를 확인한다.

  *ex) 내외부 연계 시스템 네트워크 연결 정보*

  | 구분 | 시스템 ID | Hostname | IP   | Port  | Login ID | Password | DB Type | DB User | DB User PW |
  | ---- | --------- | -------- | ---- | ----- | -------- | -------- | ------- | ------- | ---------- |
  | 내부 | ACS-001   | HOST1    | IP1  | 40001 | LID1     | PW1      | Oracle  | UID1    | UPW1       |
  | ``   | ACS-002   | HOST2    | IP2  | 40001 | LID2     | PW2      | Oracle  | UID2    | UPW2       |
  | ``   | ACS-003   | HOST3    | IP3  | 40001 | LID3     | PW3      | Oracle  | UID3    | UPW3       |
  | ``   | ACS-004   | HOST4    | IP4  | 40001 | LID4     | PW4      | DB1     | UID4    | UPW4       |
  | 외부 | ACS-005   | HOST5    | IP5  |       | LID5     | PW5      | DB2     | UID5    | UPW5       |
  | ``   | ACS-006   | HOST6    | IP6  |       | LID6     | PW6      | DB3     | UID6    | UPW6       |

### 4. 내·외부 시스템 네트워크 연결 정보 식별

내외부 시스템 네트워크 연결 정보는 시스템 로그인 및 DB 정보를 의미한다.

* 인터페이스 관련 자료들을 기반으로 내외부 시스템을 연계하는데 필요한 네트워크 연결 정보를 확인한다.

*ex) 내외부 연계 시스템 네트워크 연결 정보*

| 구분 | 시스템 ID | Hostname | IP   | Port  | Login ID | Passwd | DB Type | DB User ID | DB User PW |
| ---- | --------- | -------- | ---- | ----- | -------- | ------ | ------- | ---------- | ---------- |
| 내부 | ACS-001   | HOST1    | IP1  | 40001 | LID1     | PW1    | Oracle  | UID1       | UPW1       |
| ``   | ACS-002   | HOST2    | IP2  | 40001 | LID2     | PW2    | Oracle  | UID2       | UPW2       |
| ``   | ACS-003   | HOST3    | IP3  | 40001 | LID3     | PW3    | Oracle  | UID3       | UPW3       |
| ``   | ACS-004   | HOST4    | IP4  | 40001 | LID4     | PW4    | DB1     | UID4       | UPW4       |
| 외부 | ACS-005   | HOST5    | IP5  |       | LID5     | PW5    | DB2     | UID5       | UPW5       |
| ``   | ACS-006   | HOST6    | IP6  |       | LID6     | PW6    | DB2     | UID6       | UPW6       |

### 5. 인터페이스 식별

인터페이스를 식별하는 것은 인터페이스 요구사항 명세서와 인터페이스 요구사항 목록을 기반으로 개발할 시스템과 이와 연계할 내외부 시스템 사이의 인터페이스를 식별하고 인터페이스 목록을 작성하는 것

*ex) 인터페이스 목록*

| 인터페이스 ID | 인터페이스명             | 설명                                                         | 관련 요구사항 |
| ------------- | ------------------------ | ------------------------------------------------------------ | ------------- |
| IFID-001      | 지급 정보 전송           | 매일 1회 지급 대상 건에 대한 지급 데이터를 은행에 전송       | IRE-001       |
| IFID-002      | 은행 수금 내역 수신      | 매일 은행으로부터 입금 내역을 전송 받아 자동으로 가수금 전표를 생성 | IRE-002       |
| IFID-003      | 은행 계좌 잔액 수신      | 통장 잔액 확인                                               | IRE-003       |
| IFID-004      | 예금주 조회              | 예금주 정보 조회                                             | IRE-004       |
| IFID-005      | 법인 카드 사용 내역 조회 | 매일 1회 카드사로부터 법인 카드 사용 내역을 수신받아 회계시스템 DB에 저장 | IRE-005       |
| IFID-006      | 고객 로그인              | 고객이 입력한 로그인 정보의 일치여부 확인                    | IRE-006       |
| IFID-007      | 고객 계약 조회           | 고객 계약에 대한 내용 조회                                   | IRE-007       |

### 6. 인터페이스 시스템 식별

인터페이스 시스템을 식별하는 것은 인터페이스별로 인터페이스에 참여하는 시스템들을 송신 시스템과 수신 시스템으로 구분하여 작성하는 것이다.

*ex) 인터페이스 송수신 시스템 식별*

| 인터페이스 ID | 인터페이스명             | 인터페이스 구분 | 송신 시스템 | 수신 시스템 |
| ------------- | ------------------------ | --------------- | ----------- | ----------- |
| IFID-001      | 지급 정보 전송           | 대외            | 회계        | 길벗은행    |
| IFID-002      | 은행 수금 내역 수신      | 대외            | 회계        | 길벗은행    |
| IFID-003      | 은행 계좌 잔액 수신      | 대외            | 회계        | 길벗은행    |
| IFID-004      | 예금주 조회              | 대외            | 회계        | 길벗은행    |
| IFID-005      | 법인 카드 사용 내역 조회 | 대외            | 회계        | 길벗카드    |
| IFID-006      | 고객 로그인              | 대내            | 홈페이지    | 고객        |
| IFID-007      | 고객 계약 조회           | 대내            | 홈페이지    | 고객        |

## 32. 송수신 데이터 식별

### 1. 식별 대상 데이터

식별 대상 데이터는 송수신 시스템 사이에서 교횐되는 데이터로, 규격화된 표준 형식에 따라 전송된다.

* 교환되는 데이터의 종류에는 인터페이스 표준 항목, 송수신 데이터 항목, 공통 코드가 있다.

* 인터페이스 표준 항목

  * 인터페이스 표준 항목은 송수신 시스템을 연계하는데 표준적으로 필요한 데이터를 의미한다.

  * 인터페이스 표준 항목은 시스템 공통부와 거래 공통부로 나뉜다.

    | 인터페이스 표준 항목 | 내용                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | 시스템 공통부        | * 시스템 간 연동 시 필요한 공통 정보이다.<br />* 구성 정보에는 인터페이스 ID, 전송 시스템 정보, 서비스 코드 정보, 응답 결과 정보, 장애 정보 등이 있다. |
    | 거래 공통부          | * 시스템들이 연동된 후 송수신 되는 데이터를 처리할 때 필요한 정보이다.<br />* 구성 정보에는 직원 정보, 승인자 정보, 기기 정보, 매체 정보 등이 있다. |

* 송수신 데이터 항목

  * 송수신 데이터 항목은 송수신 시스템이 업무를 수행하는 데 사용하는 데이터이다.
  * 전통되는 데이터 항목과 순서는 인터페이스별로 다르다.

* 공통 코드

  * 공통 코드는 시스템들에서 공통적으로 사용하는 코드이다.
  * 연계 시스템이나 연계 소프트웨어에서 사용하는 상태 및 오류 코드 등과 같은 항목에 대해 코드값과 코드명, 코드 설명 등을 공통 코드로 관리한다.

### 2. 정보 흐름 식별

정보 흐름을 식별하는 것은 개발할 시스템과 내외부 시스템 사이에서 전송되는 정보들의 방향성을 식별하는 것이다.

* 개발할 시스테모가 내외부 시스템에 대한 각각의 인터페이스 목록을 확인하여 정보 흐름을 식별한다.
* 식별한 정보 흐름을 기반으로 송수신 시스템 사이에서 교환되는 주요 데이터 항목이나 정보 그룹을 도출한다.

### 3. 송수신 데이터 식별

개발할 시스템과 연계할 내외부 시스템 사이의 정보 흐름과 데이터베이스 산출물을 기반으로 송수신 데이터를 식별한다.

* 송수신 데이터의 종류에는 인터페이스 표준 항목에 대한 데이터 항목과 코드성 데이터 항목이 있다.

* 인터페이스 표준 항목과 송수신 데이터 항목 식별

  송수신 시스템 사이의 교환 범위를 확인하고 인터페이스 표준 항목에 대해 송수신 데이터 항목을 식별한다.

  *ex) 송수신 데이터 항목 식별*

  | 인터페이스 ID | 인터페이스명   | 정보 그룹 | 관련 DB | 데이터 항목                                            |
  | ------------- | -------------- | --------- | ------- | ------------------------------------------------------ |
  | IFID-008      | 사원 정보 저장 | 사원 정보 | 인사 DB | 사원정보, 사원명, 소속, 직급, 담당업무, 연락처, 이메일 |
  | IFID-009      | 조직 정보 저장 | 조직 정보 | 인사 DB | 조직코드, 조직명, 조직장명, 조직장 사원번호            |

* 코드성 데이터 항목 식별

  코드성 데이터 항목에 대해 코드, 코드명, 코드 설명 등의 코드 정보를 식별한다.

  *ex) 코드성 데이터 항목 식별*

  | 코드분류명       | 코드 | 코드명     | 코드 설명            |
  | ---------------- | ---- | ---------- | -------------------- |
  | 조직 코드        | 001  | 인사부     | 인사부의 조직 코드   |
  | 조직 코드        | 002  | 영업부     | 영업부의 조직 코드   |
  | 가맹점 업종 코드 | 111  | 음식점     | 음식점 업종 코드     |
  | 가맹점 업종 코드 | 222  | 의류판매점 | 의류판매점 업종 코드 |

* 코드성 데이터 항목에 대해 송신 시스템에서 사용하는 코드 정보와 수신 시스템에서 사용하는 코드 정보가 동일한 경우 공통 코드 정보를 확보하고, 다른 경우 매핑 필요 대상으로 분류하여 양쪽 시스템에서 사용하는 코드 정보를 확보한다.

## 33. 인터페이스 방법 명세화

### 1. 인터페이스 방법 명세화의 개념

인터페이스 방법 명세화는 내외부 시스템이 연계하여 작동할 때 인터페이스별 송수신 방법, 송수신 데이터, 오류 식별 및 처리 방안에 대한 내용을 문서로 명확하게 정리하는 것이다.

* 인터페이스별로 송수신 방법을 명세화하기 위해서는 시스템 연계 기술, 인터페이스 통신 유형, 처리 유형, 발생 주기 등에 대한 정보가 필요하다.

### 2. 시스템 연계 기술

시스템 연계 기술은 개발할 시스템과 내외부 시스템을 연꼐할 때 사용되는 기술을 의미한다.

* 주요 시스템 연계 기술에는 DB Link, API/Open API, 연계 솔루션, Socket, Web Service 등이 있다.

  * DB Link

    DB에서 제공하는 DB Link 객체를 이용하는 방식이다.

  * API/Open API

    송신 시스템의 데이터베이스에서 데이터를 읽어 와 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램이다.

  * 연계 솔루션

    EAI 서버와 송수신 시스템에 설치되는 클라이언트를 이용하는 방식이다.

  * Socket

    서버는 통신을 위한 소켓을 생성하여 포트를 할당하고 클라이언트의 통신 요청 시 클라이언트와 연결하여 통신하는 네트워크 기술이다.

  * Web Service

    웹 서비스에서 WSDL과 UDDI, SOAP 프로토콜을 이요하여 연계하는 서비스이다.

### 3. 인터페이스 통신 유형

인터페이스 통신 유형은 개발할 시스템과 내외부 시스템 간 데이터를 송수신하는 형태를 의미한다.

* 인터페이스 통신 유형에는 단방향, 동기, 비동기 방식 등이 있다.

  * 단방향

    시스템에서 거래를 요청만 하고 응답이 없는 방식이다.

  * 동기

    시스템에서 거래를 요청하고 응답이 올 때까지 대기(Request-Reply)하는 방식이다.

  * 비동기

    시스템에서 거래를 요청하고 다른 작업을 수행하다 응답이 오면 처리하는 방식(Send-Receive, Send-Receive-Acknowledge, Publish-Subscribe)이다.

### 4. 인터페이스 처리 유형

인터페이스 처리 유형은 송수신 데이터를 어떤 형태로 처리할 것인지에 대한 방식을 의미한다.

* 업무의 성격과 송수신 데이터 전송량을 고려하여 실시간, 지연 처리, 배치 방식 등으로 구분한다.

  * 실시간 방식

    사용자가 요청한 내용을 바로 처리해야 할 때 사용하는 방식이다.

  * 지연 처리 방식

    데이터를 매건 단위로 처리할 경우 비용이 많이 발생할 때 사용하는 방식이다.

  * 배치 방식

    대량의 데이터를 처리할 때 사용하는 방식이다.

### 5. 인터페이스 발생 주기

인터페이스 발생 주기는 개발할 시스템과 내외부 시스템 간 송수신 데이터가 전송되어 인터페이스가 사용되는 주기를 의미한다.

* 인터페이스 발생 주기는 업무의 성격과 송수신 데이터 전송량을 고려하여 매일, 수시, 주 1회 등으로 구분한다.

### 6. 송수신 방법 명세화

송수신 방법 명세화는 내외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 연계 방식, 통신 및 처리 유형, 발생 주기 등의 송수신 방법을 정의하고 명세를 작성하는 것이다.

* 연계 방식, 통신 유형, 연계 처리 형태는 시스템 인터페이스 설계 시 작성한 아키텍처 정의서를 기반으로 하여 업무 및 데이터의 성격, 연계 데이터 발생 건수, 연계 시스템의 기술 구조, 시스템 간의 성능 등을 고려하여 작성한다.

*ex) 인터페이스 송수신 방법 명세화*

| 인터페이스 ID | 인터페이스명        | 송신 시스템 | 수신 시스템 | 연계 방식   | 통신 유형 | 연계 처리 형태 | 연계 주기 |
| ------------- | ------------------- | ----------- | ----------- | ----------- | --------- | -------------- | --------- |
| IFID-001      | 지급 정보 전송      | 회계        | 길벗은행    | EAI         | 요청/응답 | 실시간         | 메일      |
| IFID-002      | 은행 수금 내역 수신 | 회계        | 길벗은행    | EAI         | 요청/응답 | 실시간         | 메일      |
| IFID-003      | 은행 계좌 잔액 수신 | 회계        | 길벗은행    | Socket      | 요청/응답 | 실시간         | 수시      |
| IFID-004      | 예금주 조회         | 회계        | 길벗은행    | Socket      | 요청/응답 | 실시간         | 수시      |
| IFID-005      | 법인 카드 사용 내역 | 회계        | 길벗카드    | Web Service | 요청/응답 | 실시간         | 메일      |
| IFID-006      | 고객 로그인         | 홈페이지    | 고객        | EAI         | 단방향    | 배치           | 메일      |
| IFID-007      | 고객 계약 조회      | 홈페이지    | 고객        | DB Link     | 단방향    | 배치           | 메일      |

### 7. 송수신 데이터 명세화

송수신 데이터 명세화는 내외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 인터페이스 시 필요한 송수신 데이터에 대한 명세를 작성하는 것이다.

* 인터페이스별로 테이블 정의서와 파일 레이아웃에서 연계하고자 하는 테이블 또는 파일 단위로 송수신 데이터에 대한 명세를 작성한다.

*ex) 송수신 데이터 명세화*

![img](https://velog.velcdn.com/images/esjw_/post/fbda5ded-1e56-4862-9ef5-5fe5f170d093/image.png)

### 8. 오류 식별 및 처리 방안 명세화

오류 식별 및 처리 방안 명세화는 내외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 인터페이스 시 발생할 수 있는 오류를 식별하고 오류 처리 방안에 대한 명세를 작성하는 것이다.

* 시스템 및 전송 오류, 연계 프로그램 등에서 정의한 예외 상황 등 대내외 시스템 연계 시 발생할 수 있는 다양한 오류 상황을 식별하고 분류한다.

  ![img](https://velog.velcdn.com/images/esjw_/post/bad6f530-e2c6-420d-8f1e-ec36ca0078bb/image.png)

* 오류 상황에 대해 오류 코드, 오류 메시지, 오류 설명, 해결 방법 등을 명세화 한다.

  *ex) 오류 식별 및 처리 방안 명세화*

  | 오류 코드 | 오류 메시지                             | 설명                                                         | 해결 방법                                                    |
  | --------- | --------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | ES10001   | 연계 서버에 접속할 수 없음              | 연계 서버의 네트워크 회선 오류 등으로 인해 연계 서버에 접속할 수 없음 | 연계 서버의 네트워크 회선 오류 여버를 확인 후 조치           |
  | ES50001   | 연계 서버에서 데이터 변환 에러가 발생함 | 연계 서버에서 데이터 변환 과정에서 유효하지 않은 코드값으로 인해 매핑 오류가 발생함 | 미등록 코드를 코드 테이블과 매핑 정의서에 등록한 후 재실행   |
  | SD40001   | 송신 시스템에서 데이터 조회에 실패함    | 송신 시스템의 인터페이스 프로그램에서 전송할 데이터를 DB에서 읽어 오지 못함 | 데이터페이스 접근 권한 문제, 작동 여부, 데이터 테이블 삭제 등을 확인 후 재실행 |

## 34. 시스템 인터페이스 설계서 작성

### 1. 시스템 인터페이스 설계서의 개요

시스템 인터페이스 설계서는 시스템의 인터페이스 현황을 확인하기 위해 시스템이 갖는 인터페이스 목록과 각 인터페이스의 상세 데이터 명세를 정의한 문서이다.

* 시스템 인터페이스 설계서는 시스템 인터페이스 목록과 시스템 인터페이스 정의서로 구성된다.
* 시스템 인터페이스 설계서는 인터페이스 송수신 방법과 인터페이스 송수신 데이터 명세화 과정에서 작성한 산출물을 기반으로 작성한다.
* 시스템 인터페이스 설계서를 작성한 후에는 시스템 인터페이스 목록에 있는 각각의 인터페이스를 시스템 인터페이스 정의서의 내용과 비교하여 누락되거나 보완이 필요한 경우 내용을 수정한다.
* 시스템 인터페이스 설계서는 내외부 모듈 간 공통적으로 제공되는 기능과 각 데이터의 인터페이스를 확인하는데 사용된다.

### 2. 시스템 인터페이스 목록 작성

시스템 인터페이스 목록은 업부 시스템과 내외부 시스템 간 데이터를 주고받는 경우에 사용하는 인터페이스에 대해 기술한 것이다.

* 시스템 인터페이스 목록에는 연계 업무와 연계에 참여하는 송수신 시스템의 정보, 연계 방식과 통신 유형 등에 대한 정보를 기록한다.

### 3. 시스템 인터페이스 정의서 작성

시스템 인터페이스 정의서는 인터페이스별로 시스템 간의 연계를 위해 필요한 데이터 항목 및 구현 요건 등을 기술하는 것이다.

* 시스템 인터페이스 정의서에는 데이터 송수신 시스템 간 데이터 저장소와 속성 등 상세 정보를 기록한다.

*ex) 시스템 인터페이스 정의서*

![사용자 등록이미지](https://www.jafa.or.kr/data/editor/7de7d3244e5468e0b3d510af6a3e3deb.jpg)

*ex) 상세 기능에 대한 인터페이스 정의서*

![사용자 등록이미지](https://www.jafa.or.kr/data/editor/6f0689228a9f72058ef94bdf2ec70c0a.jpg)

1. 인터페이스 ID, 인터페이스명, 처리 유형, 통신 유형, 주기, 인터페이스 구분, 데이터 포맷은 인터페이스 목록을 참고하여 기재한다.
2. 인터페이스 송수신 데이터 명세를 참조하여 기재한다.
3. 코드 매핑 규칙을 작성한다. 매핑 규칙은 송수신 시스템의 항목이 단순 1:1이 아니기 때문에 병합, 변환 등 별도의 처리 로직이 필요한 경우의 규칙을 기재한다.

## 35. 미들웨어 솔루션 명세

### 1. 미들웨어의 개념 및 종류

미들웨어는 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어이다.

* 미들웨어는 표준화된 인터페이스를 제공함으로써 시스템 간의 데이터 교환에 일관성을 보장한다.
* 미들웨어는 통신 제공 방법이나 기능에 따라 DB, RPC, MOM, TP-Monitor, ORB, WAS 등으로 구분한다.

### 2. DB

DB는 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어이다.

* DB를 사용하여 시스템을 구축하는 경우 보통 2-Tier 아키텍처라고 한다.
* 대표적인 DB의 종류에는 마이크로소프트의 ODBC, 볼랜드의 IDAPI, 오라클의 Glue 등이 있다.

### 3. RPC(Remote Procedure Call)

RPC(원격 프로시저 호출)는 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 방식의 미들웨어이다.

* 대표적인 RPC의 종류에는 이큐브시스템스의 Entera, OSF의 ONC/RPC 등이 있다.

### 4. MOM(Message Oriented Middleware)

MOM(메시지 지향 미들웨어)은 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어이다.

* 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용된다.
* 대표적인 MOM의 종류에는 IBM의 MQ, 오라클의 Message Q, JCP의 JMS 등이 있다.

### 5. TP-Monitor(Transaction Processing Monitor)

TP-Monitor(트랜잭션 처리 모니터)는 항공기나 철도 예약 업무 등과 같은 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어이다.

* 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용된다.
* 대표적인 TP-Monitor의 종류에는 오라클의 tuxedo, 티맥스소프트의 tmax 등이 있다.

### 6. ORB(Object Request Broker)

ORB(객체 요청 브로커)는 객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현한 미들웨어이다.

* 최근에는 TP-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있다.
* 대표적인 ORB의 종류에는 Micro Focus의 Orbix, OMG의 CORBA 등이 있다.

### 7. WAS(Web Application Server)

WAS는 정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어이다.

* 클라이언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어이다.
* HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현이 가능하다.
* 대표적인 WAS의 종류에는 오라클의 WebLogic, IBM의 WebSphere 등이 있다.

### 8. 미들웨어 솔루션 식별

미들웨어 솔루션 식별은 개발 및 운영 환경에 사용될 미들웨어 솔루션을 확인하고 목록을 작성하는 것이다.

* 소프트웨어 아키텍처에서 정의한 아키텍처 구성 정보와 프로젝트에서 구매가 진행 중이거나 구매 예정인 소프트웨어 내역을 확인하여 개발 및 운영 환경에서 사용될 미들웨어 솔루션을 식별한다.
* 식별한 미들웨어 솔루션들에 대해 솔루션의 시스템, 구분, 솔루션명, 버전, 제조사 등의 정보를 정리한 미들웨어 솔루션 목록을 작성한다.
* 작성된 미들웨어 솔루션 목록은 이해관계자 등에게 전달하여 오류 및 누락을 확인하고 수정한다.

| 시스템             | 구분       | 솔루션명 | 버전    | 제조사    |
| ------------------ | ---------- | -------- | ------- | --------- |
| 사용자 관리 시스템 | WAS        | nginx    | ver 4.1 | nginxsoft |
| 데이터 관리 시스템 | TP-Monitor | tuxedo   | ver 2.0 | oracle    |
| 결제 관리 시스템   | WAS        | jeus     | ver 3.0 | tmaxsoft  |
| 콘텐츠 관리 시스템 | MOM        | titan    | ver 1.2 | h2o       |

### 9. 미들웨어 솔루션 명세서 작성

미들웨어 솔루션 명세서는 미들웨어 솔루션 목록의 미들웨어 솔루션별로 관련 정보들을 상세하게 기술하는 것이다.

* 미들웨어 솔루션 제품 명칭 및 버전, 제품 사용 목적 등을 솔루션에 대한 제품안내서 및 설명 자료 등을 통해 검토한다.
* 미들웨어 솔루션 제품에 대한 사용 환경과 특징 등을 솔루션 설명 자료나 관련 담당자를 통해 검토한다.
* 미들웨어 솔루션이 지원하는 시스템 범위와 정상적인 서비스 제공을 위한 환경 구성, 제공 기능 등에 대한 제약사항이 존재하는지 제품안내서 및 기술 지원 담당자를 통해 검토한다.
* 미들웨어 솔루션에 대한 상세 정보 및 제공 기능, 특징, 시스템 구성 환경 등에 대한 제약사항을 정리하여 솔루션에 대한 명세서를 작성한다.

# 2과목. 소프트웨어 개발

# 1장. 데이터 입출력 구현

## 36. 자료 구조

### 1. 자료 구조의 정의

효율적인 프로그램을 작성할 때 가장 우선적인 고려사항은 저장 공간의 효율성과 실행시간의 신속성이다. 자료 구조는 프로그램에서 사용하기 위한 자료를 기억장치의 공간 내에 저장하는 방법과 저장된 그룹 내에 존재하는 자료 간의 관계, 처리 방법 등을 연구 분석하는 것을 말한다.

* 자료 구조는 자료의 표현과 그것과 관련된 연산이다.
* 자료 구조는 일련의 자료들을 조직하고 구조화하는 것이다.
* 어떠한 자료 구조에서도 필요한 모든 연산들을 처리할 수 있다.
* 자료 구조에 따라 프로그램 실행시간이 달라진다.

### 2. 자료 구조의 분류

![img](https://cheris8.github.io/assets/images/PY/datastructure-overview.png)

### 3. 배열(Array)

배열은 동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖고 있는 집합이다.

* 배열은 정적인 자료 구조로 기억장소의 추가가 어렵고, 데이터 삭제 시 데이터가 저장되어 있던 기억장소는 빈 공간으로 남아있어 메모리 낭비가 발생한다.
* 배열은 반복적인 데이터 처리 작업에 적합한 구조다.
* 배열은 데이터마다 동일한 이름의 변수를 사용하여 처리가 간편하다.
* 배열은 사용한 첨자의 개수에 따라 n차원 배열이라 부른다.

### 4. 선형 리스트(Linear List)

선형 리스트는 일정한 순서에 의해 나열된 자료 구조이다.

* 선형 리스트는 배열을 이용하는 연속 리스트(Contiguous List)와 포인터를 이용하는 연결 리스트(Linked List)로 구분한다.
* 연속 리스트(Contiguous List)
  * 연속 리스트는 배열과 같이 연속되는 기억장소에 저장되는 자료 구조이다.
  * 연속 리스트는 기억장소를 연속적으로 배정받기 때문에 기억장소 이용 효율은 밀도기 1로서 가장 좋다.
  * 연속 리스트는 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 하며, 삽입 및 삭제 시 자료의 이동이 필요하다.
* 연결 리스트(Linked List)
  * 연결 리스트는 자료들을 반드시 연속적으로 배열시키지는 않고 임의의 기억 공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시긴 자료 구조이다.
  * 연결 리스트는 노드의 삽입 및 삭제 작업이 용이하다.
  * 기억 공간이 연속적으로 놓여 있지 않아도 저장할 수 있다.
  * 연결 리스트는 연결을 위한 링크(포인터) 부분이 필요하기 때문에 순차 리스트에 비해 기억 공간의 이용 효율이 좋지 않다.
  * 연결 리스트는 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다.
  * 연결 리스트는 중간 노드 연결이 끊어지면 다음 노드를 찾기 힘들다.

### 5. 스택(Stack)

스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다.

* 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO; Last In First Out) 방식으로 자료를 처리한다.

  <img src="/home/oem/engineer_information_processing/assets/image-20240430174657900.png" alt="image-20240430174657900" style="zoom:50%;" />

* 스택의 모든 기억 공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 오버플로(Overflow)가 발생하며, 더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생한다.

* Top

  스택으로 할당된 기억 공간에 가장 마지막으로 삽입된 자료가 기억된 위치를 가리키는 요소이다.

* Bottom

  스택의 가장 밑바닥이다.

### 6. 큐(Queue)

큐는 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조이다.

* 큐는 가장 먼저 삽입된 자료가 가장 먼저 삭제되는(FIFO; First In First Out) 방식으로 처리한다.

* 큐는 시작과 끝을 표시하는 두 개의 포인터가 있다.

  <img src="/home/oem/engineer_information_processing/assets/image-20240430175028815.png" alt="image-20240430175028815" style="zoom:50%;" />

* 프런트(F, Front) 포인터

  가장 먼저 삽입된 자료의 기억 공간을 가리키는 포인터로, 삭제 작업을 할 때 사용한다.

* 리어(R, Rear) 포인터

  가장 마지막에 삽입된 자료가 위치한 기억 공간을 가리키는 포인터로, 삽입 작업을 할 때 사용한다.

* 큐는 운영체제의 작업 스케줄링에 사용한다.

### 7. 그래프(Graph)

그래프 G는 정점 V(Vertex)와 간선 E(Edge)의 두 집합으로 이루어진다.

* 간선의 방향성 유무에 따라 방향 그래프와 무방향 그래프로 구분된다.
* 통신망(Network), 교통망, 이항관계, 연립방정식, 유기화학 구조식, 무향선분 해법 등에 응용된다.
* 트리(Tree)는 사이클이 없는 그래프(Graph)이다.

<img src="https://velog.velcdn.com/images/dongwookang/post/4b13b4ac-2c01-4709-82f1-3127468a46eb/image.png" alt="img" style="zoom:50%;" />

> ※ cf) : 방향 / 무방향 그래프의 최대 간선 수
>
> n개의 정점으로 구성된 무방향 그래프에서 최대 간선 수는 n(n-1)/2이고, 방향 그래프에서 최대 간선 수는 n(n-1)이다.
>
> *ex) 정점이 4개인 경우 무방향 그래프와 방향 그래프의 최대 간선 수* 
>
> <img src="https://blog.kakaocdn.net/dn/kWtqy/btrp96nFASw/Gb6pX1xIxutoWlw3YqwzJ0/img.png" alt="[자료구조] 그래프 개념 - (1) - undefined - 1. 그래프(Graph) 란? - 1-2. 완전 그래프 (Complete graph)" style="zoom:80%;" />
>
> * 무방향 그래프
>
>   4(4-1)/2 = 6
>
> * 방향 그래프
>
>   4(4-1) = 12

## 37. 트리(Tree)

### 1. 트리의 개요

트리는 정점(Node)과 선분(Branch)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태이다.

* 트리는 하나의 기억 공간을 노드라고 하며, 노드와 노드를 연결하는 선을 링크(Link)라고 한다.

* 트리는 가족의 계보, 조직도 등을 표현하기에 적합하다.

* 트리 관련 용어

  * 노드

    트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것

  * 근 노드(Root node)

    트리의 맨 위에 있는 노드

  * 디그리(Degree, 차수)

    각 노드에서 뻗어 나온 가지의 수

  * 단말 노드(Terminal Node) = 잎 노드(Leaf Node)

    자식이 하나도 없는 노드, 즉 디그리가 0인 노드

  * 자식 노드

    어떤 노드에 연결된 다음 레벨의 노드들

  * 부모 노드

    어떤 노드에 연결된 이전 레벨의 노드들

  * 형제 노드

    동일한 부로를 갖는 노드들

  * 트리의 디그리

    노드들이 디그리 중에서 가장 많은 수

### 2. 트리의 운행법

트리를 구성하는 각 노드들을 찾아가는 방법을 운행법(Traversal)이라 한다.

* 이진 트리를 운행하는 방법은 산술식의 표기법과 연관성을 갖는다.

* 이진 트리의 운행법은 다음 세 가지가 있다.

  ![img](https://dthumb-phinf.pstatic.net/?src=%22http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1979B3034C30819A0C67DA%22&type=w2)

  * Preorder 운행

    Root → Left →Right 순으로 운행한다. ABC

  * Inorder 운행

    Left → Root → Right 순으로 운행한다. BAC

  * Postorder 운행

    Left → Right → Root 순으로 운행한다. BCA

* Preorder 운행법의 방문 순서

  <img src="https://postfiles.pstatic.net/20151019_40/harbester_1445256629967RknoA_PNG/%B1%D7%B8%B222.png?type=w2" alt="img" style="zoom:67%;" />

  ※ 서브트리를 하나의 노드로 생각할 수 있도록 그림과 같이 서브트리 단위로 묶는다. Preorder, Inorder, Postorder 모두 공통으로 사용한다.

  1. Preorder는 Root → Left → Right이므로 A13이 된다.
  2. 1은 B2E이므로 AB2E3이 된다.
  3. 2는 DHI이므로 ABCHIE3이 된다.
  4. 3은 CFG이므로 ABDHIECFG가 된다.
     * 방문 순서 : ABDHIECFG

* Inorder 운행법의 방문 순서

  1. Inorder는 Left → Root → Right이므로 1A3이 된다.
  2. 1은 2BE이므로 2BEA3이 된다.
  3. 2는 HDI이므로 HDIBEA3이 된다.
  4. 3은 FCG이므로 HDIBEAFCG가 된다.
     * 방문 순서 : HDIBEAFCG

* Postorder

  1. Postorder는 Left → Right → Root이므로 13A가 된다.
  2. 1은 2EB이므로 2EB3A가 된다.
  3. 2는 HID이므로 HIDEB3A가 된다.
  4. 3은 FGC이므로 HIDEBFGCA가 된다.
     * 방문 순서 : HIDEBFGCA

### 3. 수식의 표기법

산술식을 계산하기 위해 기억공간에 기억시키는 방법으로 이진 트리를 많이 사용한다. 이진 트리로 만들어진 수식을 인오더, 프리오더, 포스트오더로 운행하면 각각 중위(Infix), 전위(Prefix), 후위(Postfix) 표기법이 된다.

![img](https://t1.daumcdn.net/cfile/tistory/99CA44355B66F6F524)

* 전위 표기법(PreFix)

  연산자 → Left → Right, +AB

* 중위 표기법(InFix)

  Left → 연산자 → Right, A + B

* 후위 표기법(PostFix)

  Left → Right → 연산자, AB+

#### Infix 표기를 Postfix나 Prefix로 바꾸기

* Postfix나 Prefix는 스택을 이용하여 처리하므로 Infix는 Postfix나 Prefix로 바꾸어 처리한다.
* Postfix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 뒤로 이동한 것이므로 연산자를 다시 해당 피연산자 두 개의 가운데로 옮기면 된다.
* Prefix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 앞으로 이동한 것이므로 연산자를 다시 해당 피연산자 두 개의 가운데로 옮기면 된다.

## 38. 정렬(Sort)

### 1. 삽입 정렬(Insertion Sort)

삽입 정렬은 가장 간단한 정렬 방식으로 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬한다. 

<img src="https://static.podo-dev.com/blogs/images/2019/07/10/origin/AUD5BF181224235510.PNG" alt="img" style="zoom:50%;" />

* 두 번째 키와 첫 번째 키를 비교해서 순서대로 나열(1회전)하고, 이어서 세 번째 키를 첫 번째, 두 번째 키와 비교해 순서대로 나열(2회전)하고, 계속해서 n번째 키를 앞의 n-1개의 키와 비교하여 알맞은 순서에 삽입하여 정렬하는 방식이다.
* 평균과 최악 모두 수행 시간 복잡도는 O(n^2)이다.

### 2. 쉘 정렬

쉘 정렬은 삽입 정렬(Insertion Sort)을 확장한 개념이다.

<img src="https://velog.velcdn.com/images/sungjun-jin/post/0998b733-edc2-4618-8bd3-b4458e4695d3/image.png" alt="post-thumbnail" style="zoom:50%;" />

* 입력 파일을 어떤 매개변수(h)의 값으로 서브파일을 구성하고, 각 서브파일을 Insertion 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬 방식(보통 h = n^(1/3)), 즉 임의의 레코드 키와 h값만큼 떨어진 곳의 레코드 키를 비교하여 순서화되어 있지 않으면 서로 교환하는 것을 반복하는 정렬 방식이다.
* 입력 파일이 부분적으로 정렬되어 있는 경우에 유리한 방식이다.
* 평균 수행 시간 복잡도는 O(n^1.5)이고, 최악의 수행 시간 복잡도는 O(n^2)이다.

### 3. 선택 정렬

선택 정렬은 n개의 레코드 중에서 최소값을 찾아 첫 번재 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식이다.

<img src="https://velog.velcdn.com/images/ajm0718/post/c56c2a99-4c3f-4471-b157-9f100f779053/image.png" alt="post-thumbnail" style="zoom:50%;" />

* 평균과 최악 모두 수행 시간 복잡도는 O(n^2)이다.

### 4. 버블 정렬(Bubble Sort)

<img src="https://blog.kakaocdn.net/dn/cktF30/btrJBFS6n6U/zipvEED7or08CAvWXskrHk/img.png" alt="img" style="zoom:50%;" />

* 버블 정렬은 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식이다.
* 계속 정렬 여부를 플래그 비트(f)로 결정한다.
* 평균과 최악 모두 수행 시간 복잡도는 O(n^2)이다.

### 5. 퀵 정렬(Quick Sort)

퀵 정렬은 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로 키를 기준으로 작은 값은 왼쪽에, 큰 값은 오른쪽 서브파일로 분해시키는 방식으로 정렬한다.

<img src="https://blog.kakaocdn.net/dn/3lb5Q/btrshyJIiQF/kNoD2RLRPWYXebk59C57gk/img.png" alt="img" style="zoom:50%;" />

* 위치에 관계없이 임의의 키를 분할 원소로 사용할 수 있다.

* 정렬 방식 중에서 가장 빠른 방식이다.

* 프로그램에서 되부름을 이용하기 때문에 스택(Stack)이 필요하다.

* 분할(Divide)과 정복(Conquer)을 통해 자료를 정렬한다.

  * 분할

    기준값인 피봇(Pivot)을 중심으로 정렬할 자료들을 2개의 부분집합으로 나눈다.

  * 정복

    부분집합의 원소들 중 피봇(Pivot)보다 작은 원소들은 왼쪽, 피봇보다 큰 원소들은 오른쪽 부분집합으로 정렬한다.

  * 부분집합의 크기가 더 이상 나누어질 수 없을 때까지 분할과 정복을 반복 수행한다.

* 평균 수행 시간 복잡도는 O(nlog<sub>2</sub>n)이고, 최악의 수행 시간 복잡도는 O(n^2)이다.

### 6. 힙 정렬(Heap Sort)

힙 정렬은 전이진 트리(Complete Binary Tree)를 이용한 정렬 방식이다.

<img src="https://t1.daumcdn.net/cfile/tistory/2455654F54547CB314" alt="img" style="zoom:50%;" />

* 구성된 전이진 트리를 Heap Tree로 변환하여 정렬한다.
* 평균과 최악 모두 시간 복잡도는 O(nlog<sub>2</sub>n)이다.

### 7. 2-Way 합병 정렬(Merge Sort)

2-Way Merge Sort는 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식이다. 그 방법은 다음과 같다.

<img src="https://blog.kakaocdn.net/dn/TMJkj/btqFOh3IneD/6DL0SGqullOF1CUkJsnB6k/img.png" alt="img" style="zoom:50%;" />

* 두 개의 키들을 한 쌍으로 하여 각 쌍에 대하여 순서를 정한다.
* 순서대로 정렬된 각 쌍의 키들을 합병하여 하나의 정렬된 서브리스트로 만든다.
* 위 과정에서 정렬된 서브리스트들을 하나의 정렬된 파일이 될 때까지 반복한다.
* 평균과 최악 모두 시간 복잡도는 O(nlog<sub>2</sub>n)이다.

### 8. 기수 정렬(Radix Sort) = Bucket Sort

기수 정렬은 Queue를 이용하여 자릿수(Digit)별로 정렬하는 방식이다.

<img src="https://blog.kakaocdn.net/dn/bYMUqm/btqF2RvnGa5/KUkx7AlELFFmMGYdlxOuN1/img.png" alt="img" style="zoom:80%;" />

* 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배 하였다가 버킷의 순서대로 레코드를 꺼내어 정렬한다.
* 평균과 최악 모두 시간 복잡도는 O(dn)이다.

## 39. 데이터베이스 개요

### 1. 데이터저장소

데이터저장소는 소프트웨어 개발 과정에서 다루어야 할 데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것을 의미한다.

* 데이터저장소는 논리 데이터저장소와 물리 데이터저장소로 구분된다.
* 논리 데이터저장소는 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화한 것을 의미한다.
* 물리 데이터저장소는 논리 데이터저장소에 저장된 데이터와 구조들을 소프트웨어가 운용될 환경의 물리적 특성을 고려하고 하드웨어적인 저장장치에 저장한 것을 의미한다.
* 논리 데이터저장소를 거쳐 물리 데이터저장소를 구축하는 과정은 데이터베이스를 구축하는 과정과 동일하다.

### 2. 데이터베이스

데이터베이스는 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임으로 다음과 같이 정의할 수 있다.

* 통합된 데이터(Integrated Data)

  자료의 중복은 배제한 데이터의 모임이다.

* 저장된 데이터(Stored Data)

  컴퓨터가 접근할 수 있는 저장매체에 저장된 자료이다.

* 운영 데이터(Operational Data)

  조직의 고유한 업무를 수행하는 데 존재 가치가 확실하고 없어서는 안 될 반드시 필요한 자료이다.

* 공용 데이터(Shared Data)

  여러 응용 시스템들이 공동으로 소유하고 유지하는 자료이다.

### 3. DBMS(DataBase Management System; 데이터베이스 관리 시스템)

DBMS란 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해 주는 소프트웨어이다.

* DBMS는 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템으로, 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관래하 준다.

* DBMS는 데이터베이스의 구성, 접근 방법, 유지관리에 대한 모든 책임을 진다.

* DBMS의 필수 기능에는 정의(Definition), 조작(Manipulation), 제어(Control) 기능이 있다.

  * 정의 기능

    모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능이다.

  * 조작 기능

    데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능이다.

  * 제어 기능

    * 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 무결성이 유지되도록 제어해야 한다.
    * 정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안(Security)을 유지하고 권한(Authority)을 검사할 수 있어야 한다.
    * 여러 사용자가 데이터베이스를 동시에 접근하여 데이터를 처리할 때 처리 결과가 항상 정확성을 유지하도록 병행 제어(Concurrency Control)를 할 수 있어야 한다.

### 4. DBMS의 장단점

| 장점                                                         | 단점                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| * 데이터의 논리적, 물리적 독립성이 보장된다.<br />* 데이터의 중복을 피할 수 있어 기억 공간이 절약된다.<br />* 저장된 자료를 공동으로 이용할 수 있다.<br />* 데이터의 일관성을 유지할 수 있다.<br />* 데이터의 무결성을 유지할 수 있다.<br />* 보안을 유지할 수 있다.<br />* 데이터를 표준화할 수 있다.<br />* 데이터를 통합하여 관리할 수 있다.<br />* 항상 최신의 데이터를 유지한다.<br />* 데이터의 실시간 처리가 가능하다. | * 데이터베이스의 전문가가 부족하다.<br />* 전산화 비용이 증가한다.<br />* 대용량 디스크로의 집중적인 Access로 과부하(Overhead)가 발생한다.<br />* 파일의 예비(Back up)와 회복(Recovery)이 어렵다.<br />* 시스템이 복잡하다. |

> ※ cf) : 데이터의 독립성
>
> 데이터의 독립성으 종속성에 대비되는 말로 DBMS의 궁극적 목표이기도 하다. 데이터의 독립성에는 논리적 독립성과 물리적 독립성이 있다.
>
> * 논리적 독립성
>
>   응용 프로그램과 데이터베이스를 독립시킴으로써, 데이터의 논리적 구조를 변경시키더라도 응용 프로그램은 변경되지 않는다.
>
> * 물리적 독립성
>
>   응용 프로그램과 보조기억장치 같은 물리적 장치를 독립시킴으로써, 데이터베이스 시스템의 성능 향상을 위해 새로운 디스크를 도입하더라도 응용 프로그램에는 영향을 주지 않고 데이터의 물리적 구조만을 변경한다.

### 5. 스키마

스키마(Schema)는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세(Specification)를 기술(Description)한 메타데이터(Meta-Data)의 집합이다. 

* 스키마는 데이터베이스를 구성하는 데이터 개체(Entity), 속성(Attribute), 관계(Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다.

* 스키마는 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나누어진다.

  | 스키마 구분 | 내용                                                         |
  | ----------- | ------------------------------------------------------------ |
  | 외부 스키마 | 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것이다. |
  | 개념 스키마 | 데이터베이스의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이 필요로하는 데이터를 종합한 조직 전체의 데이터베이스로 하나만 존재한다. |
  | 내부 스키마 | 물리적 저장장치의 입장에서 본 데이터베이스 구조로서, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다. |

## 40. 데이터 입출력

### 1. 데이터 입출력의 개요

데이터 입출력은 소프트웨어의 기능 구현을 위해 데이터베이스에 데이터를 입력하거나 데이터베이스의 데이터를 출력하는 작업을 의미한다.

* 데이터 입출력은 단순 입력과 출력뿐만 아니라 데이터를 조작하는 모든 행위를 의미하며, 이와 같은 작업을 위해 SQL(Structured Query Language)을 사용한다.
* 데이터 입출력을 소프트웨어에 구현하기 위해 개발 코드 내에 SQL 코드를 삽입하거나, 객체와 데이터를 연결하는 것을 데이터 접속(Data Mapping)이라고 한다.
* SQL을 통한 데이터베이스의 조작을 수행할 때 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 트랜잭션(Transaction)이라고 한다.

### 2. SQL(Structured Query Language)

SQL은 1974년에 IBM 연구소에서 개발한 SEQUEL에서 유래한다. 국제표준 데이터베이스 언어로, 많은 회사에서 관계형 데이터베이스(RDB)를 지원하는 언어로 채택하고 있다.

* 관계대수와 관계해석을 기초로 한 혼합 데이터 언어이다.

* 질의어지만 질의 기능만 있는 것이 아니라 데이터 구조의 정의, 데이터 조작, 데이터 제어 기능을 모두 갖추고 있다.

* SQL은 데이터 정의어(DDL), 데이터 조작어(DML), 데이터 제어어(DCL)로 구분된다.

  * 데이터 정의어(DDL; Data Define Language)

    SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의하거나 변경 또는 삭제할 때 사용하는 언어이다.

  * 데이터 조작어(DML; Data Manipulation Language)

    데이터베이스 사용자가 응용 프로그램이나 질의어를 통해서 저장된 데이터를 실질적으로 처리하는 데 사용되는 언어이다.

  * 데이터 제어어(DCL; Data Control Language)

    데이터의 보안, 무결성, 회복, 병행, 수행 제어 등을 정의하는 데 사용되는 언어이다.

### 3. 데이터 접속(Data Mapping)

데이터 접속은 소프트웨어의 기능 구현을 위해 프로그래밍 코드와 데이터베이스의 데이터 연결(Mapping)하는 것을 말하며, 관련 기술로는 SQL Mapping과 ORM이 있다.

* SQL Mapping

  프로그래밍 코드 내에 SQL을 직접 입력하여 DBMS의 데이터에 접속하는 기술로, 관련 프레임워크에는 JDBC, ODBC, MyBatis 등이 있다.

* ORM(Object-Relational Mapping)

  객체지향 프로그래밍의 객체(Object)와 관계형(Relational) 데이터베이스의 데이터 연결(Mapping)하는 기술로, 관련 프레임워크에는 JPA, Hibernate, Django 등이 있다.

### 4. 트랜잭션(Transaction)

트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

* 트랜잭션을 제어하기 위해서 사용하는 명령어를 TCL(Transaction Control Language)이라고 하며, TCL의 종류에는 COMMIT, ROLLBACK, SAVEPOINT가 있다.

  * COMMIT

    트랜잭션 처리가 정상적으로 종료되어 트랜잭션이 수행한 변경 내용을 데이터베이스에 반영하는 명령어

  * ROLLBACK

    하나의 트랜잭션 처리가 비정상으로 종료되어 데이터베이스의 일관성이 깨졌을 때 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산

  * SAVEPOINT(=CHECKPOINT)

    트랜잭션 내에 ROLLBACK 할 위치인 저장점을 지정하는 명령어

## 41. 절차형 SQL

### 1. 절차형 SQL의 개요

절차형 SQL은 C, JAVA 등의 프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL을 의미한다.

* 절차형 SQL은 일반적인 프로그래밍 언어에 비해 효율은 떨어지지만 단일 SQL 문장으로 처리하기 어려운 연속적인 작업들을 처리하는데 적합하다.

* 절차형 SQL을 활용하여 다양한 기능을 수행하는 저장 모듈을 생성할 수 있다.

* 절차형 SQL은 DBMS 엔진에서 직접 실행되기 때문에 입출력 패킷이 적은 편이다.

* BEGIN ~ END 형식으로 작성되는 블록 구조로 되어 있기 때문에 기능별 모듈화가 가능하다.

* 절차형 SQL의 종류에는 프로시저, 트리거, 사용자 정의 함수가 있다.

  * 프로시저(Procedure)

    특정 기능을 수행하는 일종의 트랜잭션 언어로, 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업을 수행한다.

  * 트리거(Trigger)

    데이터베이스 시스템에서 데이터의 입력, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행된다.

  * 사용자 정의 함수

    프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리하며, 종료 시 예약어 Return을 사용하여 처리 결과를 단일값으로 반환한다.

### 2. 절차형 SQL의 테스트와 디버깅

절차형 SQL은 디버깅을 통해 기능의 적합성 여부를 검증하고, 실행을 통해 결과를 확인하는 테스트 과정을 수행한다.

* 절차형 SQL은 테스트 전에 생성을 통해 구문 오류(Syntax Error)나 참조 오류의 존재 여부를 확인한다.
* 많은 코드로 구성된 절차형 SQL의 특성상 오류 및 경고 메시지가 상세히 출력되지 않으므로 SHOW 명령어를 통해 내용을 확인하고 문제를 수정한다.
* 정상적으로 생성된 절차형 SQL은 디버깅을 통해 로직을 검증하고, 경과를 통해 최종적으로 확인한다.
* 절차형 SQL의 디버깅은 실제로 데이터베이스에 변화를줄 수 있는 삽입 및 변경 관련 SQL문을 주석으로 처리하고, 출력문을 이용하여 화면에 출력하여 확인한다.

### 3. 쿼리 성능 최적화

쿼리 성능 최적화는 데이터 입출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화하는 것이다.

* 쿼리 성능을 최적화하기 전에 성능 측정 도구인 APM을 사용하여 최적화 할 쿼리를 선정해야 한다.
* 최적화 할 쿼리에 대해 옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스를 재구성한다.

# 2장. 통합 구현

## 42. 단위 모듈 구현

### 1. 단위 모듈(Unit Module)의 개요

단위 모듈은 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것이다.

* 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부른다.
* 단위 모듈은 사용자나 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램을 의미하기도 한다.
* 두 개의 단위 모듈이 합쳐질 경우에 두 개의 기능을 구현할 수 있다.
* 단위 모듈의 구성 요소에는 처리문, 명령문, 데이터 구조 등이 있다.
* 단위 모듈은 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 한다.
* 단위 모듈을 구현하기 위해서는 단위 기능 명세서를 작성한 후 입출력 기능과 알고리즘을 구현해야 한다.

`단위 기능 명세서` → 입출력 기능 구현 → 알고리즘 구현

### 2. 단위 기능 명세서 작성

단위 기능 명세서는 설꼐 과정에서 작성하는 기능 및 코드 명세서나 설게 지침과 같이 단위 기능을 명세화한 문서들을 의미한다.

* 단위 기능 명세서를 작성하는 단계에서는 복잡한 시스템을 단순하게 구현하기 위한 추상화 작업이 필요하다.
* 단위 기능 명세서를 작성하는 단계에서는 대형 시스템을 분해하여 단위 기능별로 구분하고, 각 기능들을 계층적으로 구성하는 구조화 과정을 거친다.
* 단위 기능 명세서 작성 시 모듈의 독립적인 운용과 한 모듈 내의 정보가 다른 모듈에 영향을 주지 않도록 정보 은닉의 원리를 고려한다.

### 3. 입출력 기능 구현

입출력 기능 구현 단계에서는 단위 기능 명세서에서 정의한 데이터 형식에 따라 입출력 기능을 위한 알고리즘 및 데이터를 구현한다.

* 입출력 기능 구현 단계에서는 단위 모듈 간의 연동 또는 통신을 위한 입출력 데이터를 구현한다.
* 입출력 기능 구현 시 사용자 인터페이스인 CLI, GUI와의 연동을 고려한다.
* 입출력 기능 구현 시 네트워크나 외부 장치와의 입출력은 무료로 공개되어 있는 Open Source API를 이용하여 간편하게 구현할 수 있다.

> ※ cf) IPC(Inter-Process Communication)
>
> IPC는 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합으로, 복수의 프로세스를 수행하여 이루어지는 프로세스 간 통신까지 구현이 가능하다.
>
> * IPC의 대표 메소드 5가지
>
>   | 대표 메소드       | 내용                                                         |
>   | ----------------- | ------------------------------------------------------------ |
>   | Shared Memory     | 다수의 프로세스가 공유 가능한 메모리를 구성하여 프로세스 간 통신을 수행한다. |
>   | Socket            | 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스들 간 통신을 수행한다. |
>   | Semaphores        | 공유 자원에 대한 접근 제어를 통해 프로세스 간 통신을 수행한다. |
>   | Pipes&named Pipes | * 'Pipe'라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신을 수행한다.<br />* 하나의 프로세스가 Pipe를 이용 중이라면 다른 프로세스는 접근할 수 없다. |
>   | Message Queueing  | 메시지가 발생하면 이를 전달하는 형태로 프로세스 간 통신을 수행한다. |

### 4. 알고리즘 구현

알고리즘 구현 단계에서는 입출력 데이터를 바탕으로 단위 기능별 요구 사항들을 구현 가능한 언어를 이용하여 모듈로 구현한다.

* 알고리즘 구현 단계에서는 구현된 단위 기능들이 사용자의 요구와 일치하는지 확인하는 과정이 필요하다.
* 구현되는 모듈은 단위 기능의 종류에 따라 디바이스 드라이버 모듈, 네트워크 모듈, 파일 모듈, 프로세스 모듈 등으로 구현한다.

| 모듈 종류              | 내용                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 디바이스 드라이버 모듈 | 하드웨어 주변 장치의 동작을 구현한 모듈                      |
| 네트워크 모듈          | 네트워크 장비 및 데이터 통신을 위한 기능을 구현한 모듈       |
| 파일 모듈              | 컴퓨터 내부의 데이터 구조 영역에 접근하는 방법을 구현한 모듈 |
| 메모리 모듈            | 파일을 프로세스의 가상 메모리에 매핑/해제하는 방법, 프로세스 사이의 통신 기능을 구현한 모듈 |
| 프로세스 모듈          | 하나의 프로세스 안에서 다른 프로세스를 생성하는 방법을 구현한 모듈 |

## 43. 단위 모듈 테스트

### 1. 단위 모듈 테스트의 개요

단위 모듈 테스트는 프로그램의 단위 기능을 구현하는 모듈의 정해진 기능을 정확히 수행하는지 검증하는 것이다.

* 단위 모듈 테스트는 단위 테스트(Unit Test)라고도 하며, 화이트박스 테스트와 블랙박스 테스트 기법을 사용한다.
* 단위 모듈 테스트를 수애하기 위해서는 모듈을 단독적으로 실행할 수 있는 환경과 테스트에 필요한 데이터가 모두 준비되어야 한다.
* 모듈의 통합 이후에는 오랜 시간 추적해야 발견할 수 있는 에러들도 단위 모듈 테스트를 수행하면 쉽게 발견하고 수정할 수 있다.
* 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없다.

### 2. 테스트 케이스(Test Case)

테스트 케이스는 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서로, 명세 기반 테스트의 설계 산출물에 해당된다.

* 단위 모듈을 테스트하기 전에 테스트에 필요한 입력 데이터, 테스트 조건, 예살 결과 등을 모아 테스트 케이스를 만든다.

* 테스트 케이스를 이용하지 않고 수행하는 직관적인 테스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있다.

* ISO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소는 다음과 같다.

  | 구성 요소                                     | 내용                                       |
  | --------------------------------------------- | ------------------------------------------ |
  | 식별자(Identifier)                            | 항목 식별자, 일련 번호                     |
  | 테스트 항목(Test Item)                        | 테스트 대상(모듈 또는 기능)                |
  | 입력 명세(Input Specification)                | 입력 데이터 또는 테스트 조건               |
  | 출력 명세(Output Specification)               | 테스트 케이스 수행 시 예상되는 출력 결과   |
  | 환경 설정(Environment Needs)                  | 필요한 하드웨어나 소프트웨어의 환경        |
  | 특수 절차 요구(Special Procedure Requirement) | 테스트 케이스 수행 시 특별히 요구되는 절차 |
  | 의존성 기술(Inter-case Dependencies)          | 테스트 케이스 간의 의존성                  |

### 3. 테스트 프로세스

테스트 프로세스는 테스트를 위해 수행하는 모든 작업들이 테스트의 목적과 조건을 달성할 수 있도록 도와주는과정이다.

#### 테스트 프로세스 5단계

1. 계획 및 제어 단계

   테스트 목표를 달성하기 위한 계획을 수립하고, 계획대로 진행되도록 제어하는 단계

2. 분석 및 설계 단계

   테스트 목표를 구체화하여 테스트 시나리오와 테스트 케이스를 작성하는 단계

3. 구현 및 실현 단계

   * 효율적인 테스트 수행을 위해 테스트 케이스들을 조합하여 테스트 프로시저에 명세하는 단계이다.
   * 모듈의 환경에 적합한 단위 테스트 도구를 이용하여 테스트를 수행하는 단계이다.

4. 평가 단계

   테스트가 계획과 목표에 맞게 수행되었는지 평가하고 기록하는 단계

5. 완료 단계

   이후의 테스트를 위한 참고 자료 및 테스트 수행에 대한 증거 자료로 활용하기 위해 수행 과정과 산출물을 기록 및 저장하는 단계

## 44. 개발 지원 도구

### 1. 통합 개발 환경(IDE; Integrated Development Environment)

통합 개발 환경은 개발에 필요한 환경, 즉 편집기, 컴파일러, 디버거 등의 다양한 틀을 하나의 인터페이스로 통합하여 제공하는 것을 의미한다.

* 통합 개발 환경 도구는 통합 개발 환경을 제공하는 소프트웨어를 의미한다.

* 통합 개발 환경 도구는 코드의 자동 생성 및 컴파일이 가능하고 추가 기능을 위한 도구들을 다운로드하여 추가할 수 있다.

* 통합 개발 환경 도구는 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정이 용이하다.

* 통합 개발 환경 도구는 외부의 다양한 서비스와 연동하여 개발에 편의를 제공하고 필요한 정보를 공유할 수 있다.

* 통합 개발 환경을 지원하는 도구는 플랫폼, 운영체제, 언어별로 다양하게 존재하며, 대표적인 도구는 다음과 같다.

  | 프로그램            | 개발사                   | 플랫폼        | 운영체제                 | 지원 언어                          |
  | ------------------- | ------------------------ | ------------- | ------------------------ | ---------------------------------- |
  | 이클립스            | Eclipse Foundation, IBM  | 크로스 플랫폼 | Windows, Linux, MacOS 등 | Java, C, C++, PHP, JSP 등          |
  | 비주얼 스튜디오     | Microsoft                | Win32, Win64  | Windows                  | Basic, C, C++, C#, .NET 등         |
  | 엑스 코드           | Apple                    | Mac, iPhone   | MacOS, iOS               | C, C++, C#, Java, AppleScript 등   |
  | 안드로이드 스튜디오 | Google                   | Android       | Windows, Linux, MacOS    | Java, C, C++                       |
  | IDEA                | JetBrains(이전 IntelliJ) | 크로스 플랫폼 | Windows, Linux, MacOS    | Java, JSP, XML, Go, Kotlin, PHP 등 |

### 2. 빌드 도구

빌드는 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물을 말한다.

* 빌드 도구는 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리(Preprocessing), 컴파일(Compile) 등의 작업을 수행하는 소프트웨어를 말한다.

* 대표적인 도구로는 Ant, Maven, Gradle 등이 있다.

  | 빌드 도구              | 내용                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | Ant(Another Neat Tool) | * 아파치 소프트웨어 재단에서 개발한 소프트웨어로, 자바 프로젝트의 공식적인 빌드 도구로 사용되고 있다.<br />* XML 기반의 빌드 스크립트를 사용하며, 자유도와 유연성이 높아 복잡한 빌드 환경에도 대처가 가능하다.<br />* 정해진 규칙이나 표준이 없어 개발자가 모든 것을 정의하며, 스크립트의 재사용이 어렵다. |
  | Maven                  | * Ant와 동일한 아파치 소프트웨어 재단에서 개발된 것으로, Ant의 대안으로 개발되었다.<br />* 규칙이나 표준이 존재하여 예외 사항만 기록하면 되며, 컴파일과 빌드를 동시에 수행할 수 있다.<br />* 의존성(Dependency)을 설정하여 라이브러리를 관리한다. |
  | Gradle                 | * 기존의 Ant와 Maven을 보완하여 개발된 빌드 도구이다.<br />* 한스 도커 외 6인의 개발자가 모여 공동 개발하였다.<br />* 안드로이드 스튜디오의 공식 빌드 도구로 채택된 소프트웨어이다.<br />* Maven과 동일하게 의존성을 활용하며, 그루비(Groovy) 기반의 빌드 스크립트를 사용한다. |

### 3. 기타 협업 도구

협업 도구는 개발에 참여하는 사람들이 서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구로, 협업 소프트웨어, 그룹웨어 등으로 불린다.

* 협업 도구에는 일정 관리, 업무흐름 관리, 정보 공유, 커뮤니케이션 등의 업무 보조 도구가 포함되어 있다.

* 협업 도구는 웹 기반, PC, 스마트폰 등 다양한 플랫폼에서 사용할 수 있도록 제공된다.

* 협업 도구에 익숙하지 않거나 이용할 의지가 없으면 협업 도구가 오히려 협업의 방해 요소가 될 수 있다.

* 협업 도구의 종류

  | 도구                      | 내용                                                         |
  | ------------------------- | ------------------------------------------------------------ |
  | 프로젝트 및 일정 관리     | * 전체 프로젝트와 개별 업무들의 진행 상태, 일정 등을 공유하는 기능을 제공한다.<br />* 종류 : 구글 캘린더, 분더리스트, 트렐로, 지라, 플로우 등 |
  | 정보 공유 및 커뮤니케이션 | * 주제별로 구성원들을 지목하여 방을 개설한 후 정보를 공유하고 대화하는 것이 가능하다.<br />* 파일 관리가 간편하고, 의사소통이 자유로운 것이 특징이다.<br />* 종류 : 슬랙(Slack), 잔디(Jandi), 테스트월드(Testworld) 등 |
  | 디자인                    | * 디자이너가 설계한 UI나 이미지의 정보들을 코드화하여 개발자에게 전달하는 기능을 제공한다.<br />* 종류 : 스케치(Sketch), 제플린(Zeplin) 등 |
  | 기타                      | * 아이디어 공유에 사용되는 에버노트(Evernote)<br />* API를 문서화하여 개발자들 간 협업을 도와주는 스웨거(Swagger)<br />* 깃(Git)의 웹호스팅 서비스인 깃허브(GitHub) |

